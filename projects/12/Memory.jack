// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */
class Memory {
  static Array ram;  // Access to the whole RAM
  static Array heap;
  static int freeList;  // FIXME: Rename to first free?
  static int endListNextAddress;  // The next address of the last element in the list

  /** Initialize the class. */
  function void init() {
    // NOTE: We cannot call the Array constructor we need access to the whole RAM
    //       and the constructor would allocate space in the heap
    //       As Jack is weakly typed the below is an allowed thing to do
    let ram=0;
    // We use the same trick as above with the heap
    let heap = 2048;  // Heap base
    let freeList = heap;  // Weak typing, will be the integer 2048

    let endListNextAddress = 2048;

    // FIXME: Not sure what these are used to
    let heap[0] = 0;  // next
    let heap[1] = 14334;  // length
    return;
  }

  /**
   * Returns the RAM value at the given address.
   *
   * \param address The address to peek at
   * \return The value at the peeked address
   */
  function int peek(int address) {
    return ram[address];
  }

  /**
   * Set the RAM value at the given address to the given value.
   *
   * \param address The address to poke
   * \param value The value to assign the address
   */
  function void poke(int address, int value) {
    let ram[address] = value;
    return;
  }

  /** Find an available RAM block.
   *
   * \param size Size of the desired RAM block
   * \return A reference to the base address of the RAM block
   */
  function int alloc(int size) {
    var int requestedBlockSize;
    var int curFreeListPrevAddress;
    var int curFreeListCurAddress;
    var int curFreeListNextAddress;
    var int curFreeListSize;
    var int carvedOutStartAddress;

    // Initialization
    let requestedBlockSize = size + 2;
    let curFreeListPrevAddress = -1;  // At the very start we do not have a previous address
    let curFreeListCurAddress = 2048;  // Heap base
    let curFreeListNextAddress = heap[0];
    let curFreeListSize = peek(curFreeListNextAddress + 1);

    // NOTE: The condition will be true if
    //       curFreeListSize == requestedBlockSize
    while(curFreeListSize < (requestedBlockSize - 1)){
      // Jump to the next freeList block
      let curFreeListPrevAddress = curFreeListCurAddress;
      let curFreeListCurAddress = curFreeListNextAddress;
      let curFreeListNextAddress = peek(curFreeListNextAddress);
      let curFreeListSize = peek(curFreeListNextAddress + 1);
      // FIXME: We can raise an error if curFreeListNextAddress == -1
    }

    if(curFreeListSize == requestedBlockSize){
      // The whole block is consumed
      let carvedOutStartAddress = curFreeListCurAddress;

      // We must let the previous "next" point at the next for this block
      do poke(curFreeListPrevAddress, curFreeListCurAddress);
    } else {
      // Only part of block is consumed, we must update size
      // Carve out from the end of the current freeList block
      // NOTE: We add 2 to account for the overhead containing the next address and size of the current block
      let carvedOutStartAddress = (curFreeListCurAddress + 2) + curFreeListSize - requestedBlockSize;
      // Set the size
      do poke(carvedOutStartAddress + 1, size);

      // Update the available size in the non-carved out block
      do poke(curFreeListNextAddress + 1, curFreeListSize - requestedBlockSize);
    }

    // The carved out block will not have a next address, so we terminate the list with a -1
    do poke(carvedOutStartAddress, -1);

    // NOTE: +2 to account for the overhead
    return carvedOutStartAddress + 2;
  }

  /**
   * De-allocate the given object so that it's available for future allocations.
   *
   * /param object The object to de-allocate
   */
  function void deAlloc(Array object) {
    var int objectAddress;
    var int objectBaseAddress;

    // Get the address of the object (we can do this due to weak typing)
    let objectAddress = object;
    let objectBaseAddress = objectAddress - 2;  // One for "next", one for "size"

    // Let the last element of the freeList point at this address
    do poke(endListNextAddress, objectBaseAddress);
    // Update the "next" pointer in the last block of freeList
    let endListNextAddress = objectAddress;

    // Since we are appending this block to the end of the freeList,
    // it's "next" pointer must terminate
    do poke(objectBaseAddress, -1);

    return;
  }
}
