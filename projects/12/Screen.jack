// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Screen.jack

/**
 * A library of functions for displaying graphics on the screen.
 * The Hack physical screen consists of 256 rows (indexed 0..255, top to bottom)
 * of 512 pixels each (indexed 0..511, left to right). The top left pixel on
 * the screen is indexed (0,0).
 */
class Screen {
  static Array twoToThe;
  static Array screenMap;
  static boolean color;

  /** Initialize the Screen. */
  function void init() {
    let color = true;
    let screenMap = 16384;

    // We use the same trick as in the Math class
    let twoToThe = Array.new(16);
    let twoToThe[0] = 1;
    let twoToThe[1] = 2;
    let twoToThe[2] = 4;
    let twoToThe[3] = 8;
    let twoToThe[4] = 16;
    let twoToThe[5] = 32;
    let twoToThe[6] = 64;
    let twoToThe[7] = 128;
    let twoToThe[8] = 256;
    let twoToThe[9] = 512;
    let twoToThe[10] = 1024;
    let twoToThe[11] = 2048;
    let twoToThe[12] = 4096;
    let twoToThe[13] = 8192;
    let twoToThe[14] = 16384;
    // The below gives integer constant too big
    // let twoToThe[15] = 32768;
    let twoToThe[15] = 32767 + 1;
    // Needed for masking horizontal lines
    let twoToThe[16] = 0;
    return;
  }

  /** Erase the entire screen. */
  function void clearScreen() {
    var int address;
    let address = 0;
    // First screen address = 16384
    // Last screen address = 24575
    // 24575 - 16384 = 8191
    // Since we want to include the last address, we get
    while(address < 8192){
      let screenMap[address] = 0;
      let address = address + 1;
    }
    return;
  }

  /**
   * Set the current color, to be used for all subsequent drawXXX commands.
   *
   * \param b Color to set: Black is represented by true, white by false.
   */
  function void setColor(boolean b) {
    let color = b;
    return;
  }

  /**
   * Draw the (x,y) pixel, using the current color.
   *
   * NOTE: Having the row as first column is opposite of the matrix notation
   *
   * \param x The pixel column
   * \param y The pixel row
   */
  function void drawPixel(int x, int y) {
    var int address;
    var int bitValue;

    let address = (32*y) + (x/16);

    // We can use modulus 16, but it's cheaper to use bitwise & 15 which gives the same
    let bitValue = twoToThe[x & 15];

    // Instead of using peek and poke, we can set the memory directly
    if (color){
      // The color is black (i.e. 1), so we can check if any of the bits are 1
      let screenMap[address] = screenMap[address] | bitValue;
    }
    else {
      // The color is white (i.e. 0)
      // We only want white on the bit we selected, no-one else
      // To do this we can invert the bit, so that it's only 0 at the value we want to
      // turn off, and check if both bits are 1 to turn them on
      let screenMap[address] = screenMap[address] & (~bitValue);
    }
    return;
  }

  /**
   * Draw a line from pixel (x1,y1) to pixel (x2,y2), using the current color.
   *
   * NOTE: Having the row as first column is opposite of the matrix notation
   *
   * \param x1 The start column of the line
   * \param y1 The start row of the line
   * \param x2 The end column of the line
   * \param y2 The end row of the line
   */
  function void drawLine(int x1, int y1, int x2, int y2) {
    var int a;
    var int b;
    var int diff;  // diff = a*dy - b*dx

    var int xStart;
    var int xEnd;
    var int yStart;
    var int yEnd;

    var int dx;
    var int dy;
    var int dxP1;
    var int dyP1;

    var int curX;
    var int curY;

    var boolean draNWToSE;

    let a = 0;
    let b = 0;
    let diff = 0;

    // Determine start and end points of x
    if (x1<x2){
      let xStart = x1;
      let xEnd = x2;
    } else{
      let xStart = x2;
      let xEnd = x1;
    }

    // Special case for drawing straight horizontal line
    if(y1=y2){
      do Screen.drawHorizontalLine(xStart, xEnd, y1, 1);
      return;
    }

    // Determine start and end points of y
    if(y1<y2){
      let yStart = y1;
      let yEnd = y2;
    } else{
      let yStart = y2;
      let yEnd = y1;
    }

    // Special case for drawing straight vertical line
    // (No way to speed this up as the addresses is not contiguous in RAM)
    if(x1=x2){
      let curY = yStart + b;
      while(curY < yEnd){
        do Screen.drawPixel(xStart, curY);
        let curY = curY+1;
      }
      return;
    }

    // Figure out dx and dy
    let dx = xEnd - xStart;
    let dy = y2 - y1;  // NOTE: dy can be negative
    // Plus 1 as we are checking for <=
    let dxP1 = dx + 1;
    let dyP1 = dy + 1;

    // When drawing non-straight lines we will have two cases (instead of 4 as we will always have xStart < xEnd)
    // We will have the following:
    // - The screen starts with (0, 0) in the top left corner
    //   - This means that the coordinate is flipped horizontally as compared to a normal coordinate system
    // - y is increasing downwards
    // - dy is the end-point of y
    // - x and a is increasing to the right
    // - dx is the end-point of x
    // - dy/dx and b/a will be the gradients
    // - In the case where we start from NW and move towards SE
    //     - yStart will be close to y=0 and we will move towards dy
    //     - b is starting on 0 and increase with increasing y
    //     - The gradient will be POSITIVE (as we have flipped the coordinate system)
    // - In the case where we start from SW and move towards NE
    //     - yStart will be close to dy, and we will move towards y=0
    //     - b is starting on 0 and decrease with decreasing y
    //     - The gradient will be NEGATIVE (as we have flipped the coordinate system)
    // - In both cases:
    //     - If b/a is steeper than dy/dx we will move towards the right
    //         - We will check whether (b/a) > (dy/dx), which is the same as (a*dy) < (b*dx), which is the same as diff = (a*dy) - (b*dx) < 0
    //         - As the gradients are positive in the NW -> SE case this means
    //             - If the condition is true: We should move right and increase a (diff increase with dy)
    //             - If the condition is false: We should move down (i.e. increase y) and increase b (diff DECREASE with dx)
    //         - As the gradients are negative in the SW -> NE case this means
    //             - If the condition is true, we should move up (i.e. decrease y) and decrease b (diff INCREASE by dx)
    //             - If the condition is false, we should move right and increase a (diff increase by dy)
    let curX = xStart;

    if ((y1<y2) & (x1<x2)){
      // Direction is NW to SE
      let draNWToSE = true;
      let curY = y1;
    }
    if ((y1>y2) & (x1>x2)){
      // Direction is SE to NW
      let draNWToSE = true;
      let curY = y2;
      // Fix gradient to be aligned with the expectation of draNWToSE = true
      let dy = -dy;
      let dyP1 = -dyP1 + 2;
    }
    if ((y1>y2) & (x1<x2)){
      // Direction is SW to NE
      let draNWToSE = false;
      let curX = xStart;
      let curY = y1;
    }
    if ((y1<y2) & (x1>x2)){
      // Direction is NE to SW
      let draNWToSE = false;
      let curY = y2;
      // Fix gradient to be aligned with the expectation of draNWToSE = false
      let dy = -dy;
      let dyP1 = -dyP1;
    }

    if (draNWToSE){
      while ((a<dxP1) & (b<dyP1)){
        do Screen.drawPixel(curX, curY);
        if(diff < 0){
          // Go right
          let a = a + 1;
          let curX = curX + 1;
          let diff = diff + dy;
        }
        else {
          // Go down
          let b = b + 1;
          let curY = curY + 1;
          let diff = diff - dx;
        }
      }
    } else {
      while ((a<dxP1) & ~(b<dy)){
        do Screen.drawPixel(curX, curY);
        if(diff < 0){
          // Go up
          let b = b - 1;
          let curY = curY - 1;
          let diff = diff + dx;
        }
        else {
          // Go right
          let a = a + 1;
          let curX = curX + 1;
          let diff = diff + dy;
        }
      }
    }
    return;
  }


  /**
   * Draw a horizontal line.
   *
   * \param xStart The start of the line
   * \param xEnd The end of the line
   * \param y The y-coordinate
   * \param repeat How many rows to repeat the drawing for
   */
  function void drawHorizontalLine(int xStart, int xEnd, int y, int repeat){
    var int address;
    var int startAddress;
    var int endAddress;

    var int startBit;
    var int endBit;

    var int startMask;
    var int endMask;
    var int combinedMask;
    var int notStartMask;
    var int notEndMask;
    var int notCombinedMask;

    var int counter;

    let counter = 0;

    // Set the start and end address
    // | startAddress | startAddress + 1 | ... | endAddress |
    let startAddress = (32*y) + (xStart/16);
    let endAddress = (32*y) + (xEnd/16);

    // We can now have three cases
    // Recall that Hack is little-endianness
    // You would normally write a binary digit the mirrored way i.e.
    // 2**15 + 2**14 + ... + 2**0

    // Case 1:
    //     startAddress     startAddress + 1   ...      endAddress
    // | 0 1 ... 13 14 15 | 0 1 ... 13 14 15 | ... | 0 1 ... 13 14 15 |
    //            ^                                    ^
    //         startBit                              endBit

    // Case 2:
    //     startAddress        endAddress
    // | 0 1 ... 13 14 15 | 0 1 ... 13 14 15 |
    //            ^           ^
    //         startBit     endBit

    // Case 3:
    // startAddress = endAddress
    // | 0 1 2 ... 12 13 14 15 |
    //     ^           ^
    //  startBit     endBit

    let startBit = xStart & 15;
    let endBit = xEnd & 15;

    // We will create a mask for the startAddress and endAddress
    // NOTE: We can fill all bits from a number by subtracting 1 from twoToThe
    let startMask = ~(twoToThe[startBit] - 1);
    let endMask = twoToThe[endBit + 1] - 1;
    let combinedMask = startMask & endMask;

    let notStartMask = ~startMask;
    let notEndMask = ~endMask;
    let notCombinedMask = ~combinedMask;

    let address = startAddress;

    // We handle case 3 separately, and ensure that the while-loop is innermost
    if (startAddress = endAddress){
      // Instead of using peek and poke, we can set the memory directly
      if (color){
        while (counter < repeat){
          // The color is black (i.e. 1), so we can check if any of the bits are 1
          let screenMap[address] = screenMap[address] | combinedMask;
          let counter = counter + 1;
          let address = address + 32;
        }
      }
      else {
        while (counter < repeat){
          // The color is white (i.e. 0)
          // We only want white on the bit we selected, no-one else
          // To do this we can invert the bit, so that it's only 0 at the value we want to
          // turn off, and check if both bits are 1 to turn them on
          let screenMap[address] = screenMap[address] & notCombinedMask;
          let counter = counter + 1;
          let address = address + 32;
        }
      }
    }
    else {
      // Handle case 1 and 2 at the same time
      if (color){
        while(counter < repeat){
          let screenMap[startAddress] = screenMap[startAddress] | startMask;
          let screenMap[endAddress] = screenMap[endAddress] | endMask;

          // Handle the middle
          let address = address + 1;
          // NOTE: This does not include treatment of the endAddress
          while(address < endAddress){
            let screenMap[address] = color;
            let address = address + 1;
          }
          let startAddress = startAddress + 32;
          let endAddress = endAddress + 32;
          let address = startAddress;
          let counter = counter + 1;
        }
      }
      else {
        while(counter < repeat){
          let screenMap[startAddress] = screenMap[startAddress] & notStartMask;
          let screenMap[endAddress] = screenMap[endAddress] & notEndMask;

          // Handle the middle
          let address = address + 1;
          // NOTE: This does not include treatment of the endAddress
          while(address < endAddress){
            let screenMap[address] = color;
            let address = address + 1;
          }
          let startAddress = startAddress + 32;
          let endAddress = endAddress + 32;
          let address = startAddress;

          let counter = counter + 1;
        }
      }
    }
    return;
  }

  /**
   * Draws a filled rectangle whose top left corner is (x1, y1)
   * and bottom right corner is (x2,y2), using the current color.
   *
   * NOTE: Having the row as first column is opposite of the matrix notation
   *
   * \param x1 The start column of the rectangle
   * \param y1 The start row of the rectangle
   * \param x2 The end column of the rectangle
   * \param y2 The end row of the rectangle
   */
  function void drawRectangle(int x1, int y1, int x2, int y2) {
    // Strategy: Draw straight horizontal lines
    var int xStart;
    var int xEnd;
    var int yStart;
    var int yEnd;

    if (x1<x2){
      let xStart = x1;
      let xEnd = x2;
    } else{
      let xStart = x2;
      let xEnd = x1;
    }

    if(y1<y2){
      let yStart = y1;
      let yEnd = y2;
    } else{
      let yStart = y2;
      let yEnd = y1;
    }

    // Draw several straight lines
    do Screen.drawHorizontalLine(xStart, xEnd, yStart, (yEnd - yStart)+1);

    return;
  }

  /**
   * Draw a filled circle of radius r<=181 around (x,y), using the current color.
   *
   * NOTE: Having the row as first column is opposite of the matrix notation
   *
   * \param x The column of centrum of the circle
   * \param y The row of centrum the circle
   * \param r The radius of the circle
   */
  function void drawCircle(int x, int y, int r) {
    var int curY;
    var int xStart;
    var int xEnd;
    var int rSquare;
    var int length;

    var int dy;

    if (r>181){
      let r = 181;
    }

    // NOTE: No handling of out of range
    let dy = -r;
    let rSquare = r*r;

    // +1 as we want to include r
    while(dy < (r+1)){
      let length = Math.sqrt(rSquare - (dy*dy));
      let xStart = x - length;
      let xEnd = x + length;

      let curY = y + dy;

      do Screen.drawHorizontalLine(xStart, xEnd, curY, 1);

      let dy = dy + 1;
    }

    return;
  }
}
