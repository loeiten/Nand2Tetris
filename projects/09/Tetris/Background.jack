/**
 * Implements the Background class
 */

/**
 * The background is the location where all inactive tetrominos are drawn
 */
class Background {
  field int frameStartX;  // The pixel column for the start of the frame
  field int frameStartY;  // The pixel row for the start of the frame
  field int tetrominoStartX;  // The pixel column for the start of the tetromino
  field int tetrominoStartY;  // The pixel row for the start of the tetromino
  field int frameLenX;  // The length of the frame in the x direction
  field int frameLenY;  // The length of the frame in the y direction
  field int tetrominoElementSize;  // The size of a tetromino element
  field int skipRows;  // Number of invisible rows (counting from the top)
  field int meshCols;  // Number of columns in the mesh
  field int meshRows;  // Number of rows in the mesh
  field int visibleRows;  // Number of visible rows

  field Mesh backgroundMesh;  // Mesh holding the state of each element

  /**
   * Construct the Background
   *
   * \param frameStartX_ The pixel column for the start of the background
   * \param frameStartY_ The pixel row for the start of the background
   * \param frameLenX_ The length of the frame in the x direction
   * \param frameLenY_ The length of the frame in the y direction
   * \param tetrominoElementSize_ The size of a tetromino element
   * \param skipRows_ Number of invisible rows (counting from the top)
   * \param meshCols_ Number of columns for the backgroundMesh
   * \param meshRows_ Number of rows for the backgroundMesh
   */
  constructor Background new(int frameStartX_,
                             int frameStartY_,
                             int frameLenX_,
                             int frameLenY_,
                             int tetrominoElementSize_,
                             int skipRows_,
                             int meshCols_,
                             int meshRows_) {
    let frameStartX = frameStartX_;
    let frameStartY = frameStartY_;

    // The start of the tetromino is +1 padding and +1 for the line
    let tetrominoStartX = frameStartX + 2;
    let tetrominoStartY = frameStartY + 2;

    let frameLenX = frameLenX_;
    let frameLenY = frameLenY_;

    let tetrominoElementSize = tetrominoElementSize_;

    let meshCols = meshCols_;
    let meshRows = meshRows_;
    let skipRows = skipRows_;
    let visibleRows = meshRows - skipRows;

    let backgroundMesh = Mesh.new(meshCols, meshRows);

    return this;
  }

  /**
   * Destroy the Background
   *
   * Disposes:
   * - The backgroundMesh
   * - This
   */
  method void dispose (){
    do backgroundMesh.dispose();
    do Memory.deAlloc(this);
    return;
  }

  /** Return the background Mesh */
  method Mesh getBackgroundMesh(){
    return backgroundMesh;
  }

  /** Return the number of rows in the Mesh*/
  method int getMeshRows(){
    return meshRows;
  }

  /** Return the skip rows */
  method int getSkipRows(){
    return skipRows;
  }

  /** Return the visible rows */
  method int getVisibleRows(){
    return visibleRows;
  }

  /**
   * Collapse full rows
   *
   * \param rowsToCollapse Rows to collapse
   */
  method void collapse(Array rowsToCollapse){
    // We will use the following strategy:
    // 1. Iterate from the bottom row
    // 2. When a rowToRemove is encountered:
    //    a. Iterate from the bottom to the top:
    //       - If a element has state = true: Set the state of the element below to 0

    var int xInd;  // The x coordinate of the Mesh
    var int potentialCollapseRow;  // The y coordinate of the row to potentially collapse
    var int meshRow;  // The y coordinate of the mesh

    var int clearedRows;

    var bool state;

    let potentialCollapseRow = meshRows;

        // FIXME: Keeping this and everything works...removing this and get into a dealloc error
        //        Search for "ADD AFTER" to find debug stuff added after
        // do Output.moveCursor(0, 30);
        // do Output.printString("potentialCollapseRow: ");



        // do Output.moveCursor(2, 30);
        // do Output.printString("clearedRows: ");
        // do Output.moveCursor(4, 30);
        // do Output.printString("meshRow: ");

    while(potentialCollapseRow > skipRows){
      if(rowsToCollapse[potentialCollapseRow - skipRows]){
        // Start at the row immediately above the collapsed row
        // Also take into account previously cleared rows
        let meshRow = potentialCollapseRow - 1 + clearedRows;

        while(meshRow > skipRows){




        // FIXME:
        // Expect potential collapse row:
        // 38, 36, 35, 33, 32, 31, 30
        // do Output.moveCursor(1, 30);
        // do Output.printInt(potentialCollapseRow);
        // do Output.moveCursor(3, 30);
        // do Output.printInt(clearedRows);
        // do Output.moveCursor(5, 30);
        // do Output.printInt(meshRow);
        // do Sys.wait(500);





          let xInd = 0;

          // Loop over all rows
          while(xInd < meshCols){
            // Set the element of the row to be cleared to the row above
            let state = backgroundMesh.getState(xInd, meshRow);
            do backgroundMesh.setState(xInd, meshRow + 1, state);
            let xInd = xInd+1;
          }
          let meshRow = meshRow - 1;
        }
        let clearedRows = clearedRows + 1;
// FIXME:
//    do drawMesh(false, backgroundMesh, 0, 0);
//    do Sys.wait(250);
      }
      let potentialCollapseRow = potentialCollapseRow - 1;
    }

    // Draw the updated background
    do drawMesh(false, backgroundMesh, 0, 0);
    return;
  }

  /** Draw the frame */
  method void drawFrame(){
    // Draw background frame
    do Screen.setColor(true);
    do Screen.drawLine(frameStartX, frameStartY, frameStartX + frameLenX, frameStartY);
    do Screen.drawLine(frameStartX, frameStartY, frameStartX, frameStartY + frameLenY);
    do Screen.drawLine(frameStartX + frameLenX, frameStartY, frameStartX + frameLenX, frameStartY + frameLenY);
    do Screen.drawLine(frameStartX, frameStartY + frameLenY, frameStartX + frameLenX, frameStartY + frameLenY);

    return;
  }

  /**
   * Draw a mesh on the background
   *
   * \param erase Draw with color false even if state is true
   * \param mesh The Mesh to draw on the background
   * \param relativeXInd The x index of the input mesh relative to the background (counted from the top left)
   * \param relativeYInd The y index of the input mesh relative to the background (counted from the top left)
   */
  method void drawMesh(bool erase, Mesh mesh, int relativeXInd, int relativeYInd){
    var int backgroundIndex;  // Index in the background mesh
    var int backgroundXInd;  // The x coordinate of the background mesh
    var int backgroundYInd;  // The y coordinate of the background mesh
    var int meshXInd;  // The x coordinate of the input mesh
    var int meshYInd;  // The y coordinate of the input mesh
    var int startPixelX;  // The pixel column to start draw a rectangle from
    var int startPixelY;  // The pixel row to start draw a rectangle from

    var bool state;  // State of the current input mesh element

    // Will be destroyed by the Mesh
    var Array backgroundCoordinates;  // Array holding the (x, y) coordinate of the background mesh

    let backgroundIndex = skipRows * meshCols;

    // FIXME:
    //     do Output.moveCursor(3, 30);
    //     do Output.printString("backgroundIndex:");
    //     do Output.moveCursor(5, 30);
    //     do Output.printString("backgroundXInd (before): ");
    //     do Output.moveCursor(7, 30);
    //     do Output.printString("backgroundYInd (before): ");
    //     do Output.moveCursor(9, 30);
    //     do Output.printString("relativeXInd: ");
    //     do Output.moveCursor(11, 30);
    //     do Output.printString("relativeYInd: ");
    //     do Output.moveCursor(13, 30);
    //     do Output.printString("skipRows: ");
    // do Output.moveCursor(15, 30);
    // do Output.printString("tetrominoStartX: ");
    // do Output.moveCursor(17, 30);
    // do Output.printString("tetrominoStartY: ");
    // do Output.moveCursor(19, 30);
    // do Output.printString("backgroundYInd (after): ");

    while (backgroundIndex < backgroundMesh.getMeshLength()){
      // Get the background coordinates
      let backgroundCoordinates = backgroundMesh.getMeshIndices(backgroundIndex);
      let backgroundXInd = backgroundCoordinates[0];
      let backgroundYInd = backgroundCoordinates[1];

      // Get the input mesh coordinates
      let meshXInd = backgroundXInd - relativeXInd;
      let meshYInd = backgroundYInd - relativeYInd;

      // FIXME:
      // let backgroundCoordinates[0] = mesh.getCols();
      // let backgroundCoordinates[1] = mesh.getRows();
      // do Output.moveCursor(0, 30);
      // do Output.printInt(backgroundIndex);

      // Only proceed if meshXInd and meshYInd is within the range
      if (
        // Check the x coordinate
        ((-1 < meshXInd) & (meshXInd < mesh.getCols())) &
        // Check the y coordinate
        ((-1 < meshYInd) & (meshYInd < mesh.getRows()))
      ){
        // NOTE: We need the actual y-coordinate to get the state
        let state = mesh.getState(meshXInd, meshYInd);


          // FIXME:
          // do Output.moveCursor(4, 30);
          // do Output.printInt(backgroundIndex);
          // do Output.moveCursor(6, 30);
          // do Output.printInt(backgroundXInd);
          // do Output.moveCursor(8, 30);
          // do Output.printInt(backgroundYInd);
          // do Output.moveCursor(10, 30);
          // do Output.printInt(relativeXInd);
          // do Output.moveCursor(12, 30);
          // do Output.printInt(relativeYInd);
          // do Output.moveCursor(14, 30);
          // do Output.printInt(skipRows);
          // do Sys.wait(250);

        // NOTE: We only draw the active part of the mesh as the inactive part
        //       may overlap with the background
        // FIXME: Need another way of not drawing active state...if not can get probs with collapse
        // if(state){
          // Subtract rows to skip, so that we only draw the visible part of the mesh
          let backgroundYInd = backgroundYInd - skipRows;

          // FIXME:
          // do Output.moveCursor(16, 30);
          // do Output.printInt(tetrominoStartX);
          // do Output.moveCursor(18, 30);
          // do Output.printInt(tetrominoStartY);
          // do Output.moveCursor(20, 30);
          // do Output.printInt(backgroundYInd);
          // do Output.moveCursor(21, 30);

          let startPixelX = tetrominoStartX + (tetrominoElementSize*backgroundXInd) + (2*backgroundXInd);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*backgroundYInd) + (2*backgroundYInd);

          if(erase){
            do Screen.setColor(false);
          } else {
            do Screen.setColor(state);
          }
          do Screen.drawRectangle(startPixelX,
                                  startPixelY,
                                  startPixelX+tetrominoElementSize,
                                  startPixelY+tetrominoElementSize);
        // }

      }

      let backgroundIndex = backgroundIndex + 1;
    }

    return;
  }

  /**
   * Draw specific rows with a certain color
   *
   * \param rowsToDraw Rows to draw with the color
   * \param color The color to draw
   */
  method void drawRows(Array rowsToDraw, bool color){
    var int xInd;  // The x coordinate of the Mesh
    var int curRow;  // The y coordinate of the Mesh
    var int visibleRow;  // The y coordinate of visible row
    var bool drawRow;  // Whether or not to draw the row
    var int startPixelX;  // The pixel column to start draw a rectangle from
    var int startPixelY;  // The pixel row to start draw a rectangle from

    let curRow = skipRows;

    do Screen.setColor(color);

    // Loop over all visible rows
    while(curRow < meshRows){
      let visibleRow = curRow - skipRows;
      let drawRow = rowsToDraw[visibleRow];

      if(drawRow){
        let xInd = 0;

        // Loop over all rows in a column
        while (xInd < meshCols){
          let startPixelX = tetrominoStartX + (tetrominoElementSize*xInd) + (2*xInd);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*visibleRow) + (2*visibleRow);
          do Screen.drawRectangle(startPixelX, startPixelY, startPixelX+tetrominoElementSize, startPixelY+tetrominoElementSize);
          let xInd = xInd + 1;
        }
      }
      let curRow = curRow + 1;
    }

    return;
  }

  /**
   * Animate clear lines
   *
   * \param rowsToClear Rows to draw with the color
   */
  method void clearLinesAnimation(Array rowsToClear){
    var int curRow;  // The y coordinate of the Mesh
    var int visibleRow;  // The y coordinate of visible row
    var bool clearRow;  // Whether or not to draw the row
    var int startPixelX;  // The pixel column to start draw a rectangle from
    var int startPixelY;  // The pixel row to start draw a rectangle from

    var int xIndHalf;
    var int xIndRight;
    var int xIndLeft;
    var int xIndRightCounter;
    var int xIndLeftCounter;

    let xIndHalf = (meshCols/2);
    let xIndLeftCounter = 1;
    let xIndRight = xIndHalf + xIndRightCounter;
    let xIndLeft = xIndRight - xIndLeftCounter;

    do Screen.setColor(false);

    // Loop over half the xInds
    while(xIndRight < meshCols){

      // Loop over all visible rows
      let curRow = skipRows;
      while(curRow < meshRows){
        let visibleRow = curRow - skipRows;
        let clearRow = rowsToClear[visibleRow];

        if(clearRow){
          // Remove the right element
          let startPixelX = tetrominoStartX + (tetrominoElementSize*xIndRight) + (2*xIndRight);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*visibleRow) + (2*visibleRow);
          do Screen.drawRectangle(startPixelX, startPixelY, startPixelX+tetrominoElementSize, startPixelY+tetrominoElementSize);
          // Remove the left element
          let startPixelX = tetrominoStartX + (tetrominoElementSize*xIndLeft) + (2*xIndLeft);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*visibleRow) + (2*visibleRow);
          do Screen.drawRectangle(startPixelX, startPixelY, startPixelX+tetrominoElementSize, startPixelY+tetrominoElementSize);
        }

        let curRow = curRow + 1;
      }

      let xIndLeftCounter = xIndLeftCounter + 2;
      let xIndRightCounter = xIndRightCounter + 1;

      let xIndRight = xIndHalf + xIndRightCounter;
      let xIndLeft = xIndRight - xIndLeftCounter;

      do Sys.wait(100);
    }

    return;
  }

}
