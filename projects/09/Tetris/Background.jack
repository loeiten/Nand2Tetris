/**
 * Implements the Background class
 */

/**
 * The background is the location where all inactive tetrominos are drawn
 */
class Background {
  field int frameStartX;  // The pixel column for the start of the frame
  field int frameStartY;  // The pixel row for the start of the frame
  field int tetrominoStartX;  // The pixel column for the start of the tetromino
  field int tetrominoStartY;  // The pixel row for the start of the tetromino
  field int frameLenX;  // The length of the frame in the x direction
  field int frameLenY;  // The length of the frame in the y direction
  field int tetrominoElementSize;  // The size of a tetromino element
  field int skipRows;  // Number of invisible rows (counting from the top)
  field int meshCols;  // Number of columns in the mesh
  field int meshRows;  // Number of rows in the mesh
  field int visibleRows;  // Number of visible rows

  field Mesh backgroundMesh;  // Mesh holding the state of each element

  /**
   * Construct the Background
   *
   * \param frameStartX_ The pixel column for the start of the background
   * \param frameStartY_ The pixel row for the start of the background
   * \param frameLenX_ The length of the frame in the x direction
   * \param frameLenY_ The length of the frame in the y direction
   * \param tetrominoElementSize_ The size of a tetromino element
   * \param skipRows_ Number of invisible rows (counting from the top)
   * \param meshCols_ Number of columns for the backgroundMesh
   * \param meshRows_ Number of rows for the backgroundMesh
   */
  constructor Background new(int frameStartX_,
                             int frameStartY_,
                             int frameLenX_,
                             int frameLenY_,
                             int tetrominoElementSize_,
                             int skipRows_,
                             int meshCols_,
                             int meshRows_) {
    let frameStartX = frameStartX_;
    let frameStartY = frameStartY_;

    // The start of the tetromino is +1 padding and +1 for the line
    let tetrominoStartX = frameStartX + 2;
    let tetrominoStartY = frameStartY + 2;

    let frameLenX = frameLenX_;
    let frameLenY = frameLenY_;

    let tetrominoElementSize = tetrominoElementSize_;

    let meshCols = meshCols_;
    let meshRows = meshRows_;
    let skipRows = skipRows_;
    let visibleRows = meshRows - skipRows;

    let backgroundMesh = Mesh.new(meshCols, meshRows);

    return this;
  }

  /**
   * Destroy the Background
   *
   * Disposes:
   * - The backgroundMesh
   * - This
   */
  method void dispose (){
    do backgroundMesh.dispose();
    do Memory.deAlloc(this);
    return;
  }

  /** Return the background Mesh */
  method Mesh getBackgroundMesh(){
    return backgroundMesh;
  }

  /** Return the number of rows in the Mesh*/
  method int getMeshRows(){
    return meshRows;
  }

  /** Return the skip rows */
  method int getSkipRows(){
    return skipRows;
  }

  /** Return the visible rows */
  method int getVisibleRows(){
    return visibleRows;
  }

  /** Draw the frame */
  method void drawFrame(){
    // Draw background frame
    do Screen.setColor(true);
    do Screen.drawLine(frameStartX, frameStartY, frameStartX + frameLenX, frameStartY);
    do Screen.drawLine(frameStartX, frameStartY, frameStartX, frameStartY + frameLenY);
    do Screen.drawLine(frameStartX + frameLenX, frameStartY, frameStartX + frameLenX, frameStartY + frameLenY);
    do Screen.drawLine(frameStartX, frameStartY + frameLenY, frameStartX + frameLenX, frameStartY + frameLenY);

    return;
  }

  /**
   * Draw a mesh on the background
   *
   * \param erase Draw with color false even if state is true
   * \param mesh The Mesh to draw on the background
   * \param relativeXInd The x index of the input mesh relative to the background (counted from the top left)
   * \param relativeYInd The y index of the input mesh relative to the background (counted from the top left)
   */
  // FIXME: Input introduced as part of refactor
  method void drawMesh(bool erase, Mesh mesh, int relativeXInd, int relativeYInd){
    var int index;  // Index representing the Mesh element
    var int xInd;  // The x coordinate of the Mesh
    var int yInd;  // The y coordinate of the Mesh
    var int startPixelX;  // The pixel column to start draw a rectangle from
    var int startPixelY;  // The pixel row to start draw a rectangle from

    var bool state;  // State of the current Mesh element

    // Will be destroyed by the Mesh
    var Array coordinates;  // Array holding the (x, y) coordinate of the Mesh

    let index = skipRows * meshCols;

    while (index < backgroundMesh.getMeshLength()){
      let coordinates = backgroundMesh.getMeshIndices(index);
      let xInd = coordinates[0];
      let yInd = coordinates[1];
      // NOTE: We need the actual y-coordinate to get the state
      let state = backgroundMesh.getState(xInd, yInd);

      // NOTE: We only draw the active part of the mesh as the inactive part
      //       may overlap with the background
      if(state){
        // Add the relative indices
        let xInd = relativeXInd + xInd;
        // NOTE: Since both our abstract Mesh and our display start counting rows
        //       from 0, we must subtract skipRows in order not to draw the
        //       rectangle out of range
        let yInd = relativeYInd + yInd - skipRows;

        let startPixelX = tetrominoStartX + (tetrominoElementSize*xInd) + (2*xInd);
        let startPixelY = tetrominoStartY + (tetrominoElementSize*yInd) + (2*yInd);

        if(erase){
          do Screen.setColor(false);
        } else {
          do Screen.setColor(state);
        }
        do Screen.drawRectangle(startPixelX,
                                startPixelY,
                                startPixelX+tetrominoElementSize,
                                startPixelY+tetrominoElementSize);
      }

      let index = index + 1;
    }

    return;
  }

  /**
   * Draw specific rows with a certain color
   *
   * \param rowsToDraw Rows to draw with the color
   * \param color The color to draw
   */
  method void drawRows(Array rowsToDraw, bool color){
    var int xInd;  // The x coordinate of the Mesh
    var int curRow;  // The y coordinate of the Mesh
    var int visibleRow;  // The y coordinate of visible row
    var bool drawRow;  // Whether or not to draw the row
    var int startPixelX;  // The pixel column to start draw a rectangle from
    var int startPixelY;  // The pixel row to start draw a rectangle from

    let curRow = skipRows;

    do Screen.setColor(color);

    // Loop over all visible rows
    while(curRow < meshRows){
      let visibleRow = curRow - skipRows;
      let drawRow = rowsToDraw[visibleRow];

      if(drawRow){
        let xInd = 0;

        // Loop over all rows in a column
        while (xInd < meshCols){
          let startPixelX = tetrominoStartX + (tetrominoElementSize*xInd) + (2*xInd);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*visibleRow) + (2*visibleRow);
          do Screen.drawRectangle(startPixelX, startPixelY, startPixelX+tetrominoElementSize, startPixelY+tetrominoElementSize);
          let xInd = xInd + 1;
        }
      }
      let curRow = curRow + 1;
    }

    return;
  }

  /**
   * Animate clear lines
   *
   * \param rowsToClear Rows to draw with the color
   */
  method void clearLinesAnimation(Array rowsToClear){
    var int curRow;  // The y coordinate of the Mesh
    var int visibleRow;  // The y coordinate of visible row
    var bool clearRow;  // Whether or not to draw the row
    var int startPixelX;  // The pixel column to start draw a rectangle from
    var int startPixelY;  // The pixel row to start draw a rectangle from

    var int xIndHalf;
    var int xIndRight;
    var int xIndLeft;
    var int xIndRightCounter;
    var int xIndLeftCounter;

    let xIndHalf = (meshCols/2);
    let xIndLeftCounter = 1;
    let xIndRight = xIndHalf + xIndRightCounter;
    let xIndLeft = xIndRight - xIndLeftCounter;

    do Screen.setColor(false);

    // Loop over half the xInds
    while(xIndRight < meshCols){

      // Loop over all visible rows
      let curRow = skipRows;
      while(curRow < meshRows){
        let visibleRow = curRow - skipRows;
        let clearRow = rowsToClear[visibleRow];

        if(clearRow){
          // Remove the right element
          let startPixelX = tetrominoStartX + (tetrominoElementSize*xIndRight) + (2*xIndRight);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*visibleRow) + (2*visibleRow);
          do Screen.drawRectangle(startPixelX, startPixelY, startPixelX+tetrominoElementSize, startPixelY+tetrominoElementSize);
          // Remove the left element
          let startPixelX = tetrominoStartX + (tetrominoElementSize*xIndLeft) + (2*xIndLeft);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*visibleRow) + (2*visibleRow);
          do Screen.drawRectangle(startPixelX, startPixelY, startPixelX+tetrominoElementSize, startPixelY+tetrominoElementSize);
        }

        let curRow = curRow + 1;
      }

      let xIndLeftCounter = xIndLeftCounter + 2;
      let xIndRightCounter = xIndRightCounter + 1;

      let xIndRight = xIndHalf + xIndRightCounter;
      let xIndLeft = xIndRight - xIndLeftCounter;

      do Sys.wait(100);
    }

    return;
  }

  /**
   * Collapse full rows
   *
   * \param rowsToCollapse Rows to collapse
   */
  method void collapse(Array rowsToCollapse){
    // We will use the following strategy:
    // 1. Iterate from the bottom row
    // 2. When a rowToRemove is encountered:
    //    a. Iterate from the bottom to the top:
    //       - If a element has state = true: Set the state of the element below to 0

    var int xInd;  // The x coordinate of the Mesh
    var int potentialCollapseRow;  // The y coordinate of the row to potentially collapse
    var int meshRow;  // The y coordinate of the mesh

    var int clearedRows;

    var bool state;

    let potentialCollapseRow = meshRows;

    while(potentialCollapseRow > skipRows){
      if(rowsToCollapse[potentialCollapseRow - skipRows]){
        // Start at the row immediately above the collapsed row
        // Also take into account previously cleared rows
        let meshRow = potentialCollapseRow - 1 + clearedRows;
        while(meshRow > skipRows){
          let xInd = 0;

          // Loop over all rows
          while(xInd < meshCols){
            // Set the element of the row to be cleared to the row above
            let state = backgroundMesh.getState(xInd, meshRow);
            do backgroundMesh.setState(xInd, meshRow + 1, state);
            let xInd = xInd+1;
          }
          let meshRow = meshRow - 1;
        }
        let clearedRows = clearedRows + 1;
      }
      let potentialCollapseRow = potentialCollapseRow - 1;
    }

    // Draw the updated background
    do drawMesh(false, backgroundMesh, 0, 0);
    return;
  }

}
