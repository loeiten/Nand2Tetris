/**
 * Implements the Background class
 */

/**
 * The background is the location where all inactive tetrominos are drawn
 */
class Background {
  field int frameStartX;  // The pixel column for the start of the frame
  field int frameStartY;  // The pixel row for the start of the frame
  field int tetrominoStartX;  // The pixel column for the start of the tetromino
  field int tetrominoStartY;  // The pixel row for the start of the tetromino
  field int frameLenX;  // The length of the frame in the x direction
  field int frameLenY;  // The length of the frame in the y direction
  field int tetrominoElementSize;  // The size of a tetromino element
  field int skipRows;  // Number of invisible rows (counting from the top)
  field int meshCols;  // Number of columns in the mesh
  field int meshRows;  // Number of rows in the mesh
  field int visibleRows;  // Number of visible rows

  field Mesh backgroundMesh;  // Mesh holding the state of each element

  static int allocs;  // Number of times this has been allocated

  /**
   * Construct the Background
   *
   * \param frameStartX_ The pixel column for the start of the background
   * \param frameStartY_ The pixel row for the start of the background
   * \param frameLenX_ The length of the frame in the x direction
   * \param frameLenY_ The length of the frame in the y direction
   * \param tetrominoElementSize_ The size of a tetromino element
   * \param skipRows_ Number of invisible rows (counting from the top)
   * \param meshCols_ Number of columns for the backgroundMesh
   * \param meshRows_ Number of rows for the backgroundMesh
   */
  constructor Background new(int frameStartX_,
                             int frameStartY_,
                             int frameLenX_,
                             int frameLenY_,
                             int tetrominoElementSize_,
                             int skipRows_,
                             int meshCols_,
                             int meshRows_) {
    let frameStartX = frameStartX_;
    let frameStartY = frameStartY_;

    // The start of the tetromino is +1 padding and +1 for the line
    let tetrominoStartX = frameStartX + 2;
    let tetrominoStartY = frameStartY + 2;

    let frameLenX = frameLenX_;
    let frameLenY = frameLenY_;

    let tetrominoElementSize = tetrominoElementSize_;

    let meshCols = meshCols_;
    let meshRows = meshRows_;
    let skipRows = skipRows_;
    let visibleRows = meshRows - skipRows;

    let backgroundMesh = Mesh.new(meshCols, meshRows);

    let allocs = allocs + 1;

    return this;
  }

  /**
   * Destroy the Background
   *
   * Disposes:
   * - The backgroundMesh
   * - This
   */
  method void dispose (){
    let allocs = allocs - 1;
    do backgroundMesh.dispose();
    do Memory.deAlloc(this);
    return;
  }

  /** Print the number of allocs */
  method void printAlloc (){
    var String str;
    let str = "Background allocs: ";
    do Output.printString(str);
    do Output.printInt(allocs);
    do str.dispose();
    return;
  }

  /** Return the background Mesh */
  method Mesh getBackgroundMesh(){
    return backgroundMesh;
  }

  /** Return the number of rows in the Mesh*/
  method int getMeshRows(){
    return meshRows;
  }

  /** Return the skip rows */
  method int getSkipRows(){
    return skipRows;
  }

  /** Return the visible rows */
  method int getVisibleRows(){
    return visibleRows;
  }

  /**
   * Collapse full rows
   *
   * \param rowsToCollapse Rows to collapse
   */
  method void collapse(Array rowsToCollapse){
    // We will use the following strategy:
    // 1. Iterate from the bottom row
    // 2. When a rowToRemove is encountered:
    //    a. Iterate from the bottom to the top:
    //       - If a element has state = true: Set the state of the element below to 0

    var int xInd;  // The x coordinate of the Mesh
    var int potentialCollapseRow;  // The y coordinate of the row to potentially collapse
    var int meshRow;  // The y coordinate of the mesh

    var int clearedRows;

    var bool state;

    // NOTE: meshRows counts the total number of rows
    //       potentialCollapseRow will be used as a index (starting at 0)
    //       Hence we need to subtract by one
    let potentialCollapseRow = meshRows - 1;

    while(potentialCollapseRow > skipRows){
      if(rowsToCollapse[potentialCollapseRow - skipRows]){
        // Start at the row immediately above the collapsed row
        // Also take into account previously cleared rows
        let meshRow = potentialCollapseRow - 1 + clearedRows;
        while(meshRow > skipRows){
          let xInd = 0;

          // Loop over all rows
          while(xInd < meshCols){
            // Set the element of the row to be cleared to the row above
            let state = backgroundMesh.getState(meshRow, xInd);
            do backgroundMesh.setState(meshRow + 1, xInd, state);
            let xInd = xInd+1;
          }
          let meshRow = meshRow - 1;
        }
        let clearedRows = clearedRows + 1;
      }
      let potentialCollapseRow = potentialCollapseRow - 1;
    }

    // Draw the updated background
    do drawMesh(false, backgroundMesh, 0, 0);
    return;
  }

  /** Draw the frame */
  method void drawFrame(){
    // Draw background frame
    do Screen.setColor(true);
    do Screen.drawLine(frameStartX, frameStartY, frameStartX + frameLenX, frameStartY);
    do Screen.drawLine(frameStartX, frameStartY, frameStartX, frameStartY + frameLenY);
    do Screen.drawLine(frameStartX + frameLenX, frameStartY, frameStartX + frameLenX, frameStartY + frameLenY);
    do Screen.drawLine(frameStartX, frameStartY + frameLenY, frameStartX + frameLenX, frameStartY + frameLenY);

    return;
  }

  /**
   * Draw a mesh on the background
   *
   * \param erase Draw with color false even if state is true
   * \param mesh The Mesh to draw on the background
   * \param relativeYInd The y index of the input mesh relative to the background (counted from the top left)
   * \param relativeXInd The x index of the input mesh relative to the background (counted from the top left)
   */
  method void drawMesh(bool erase, Mesh mesh, int relativeYInd, int relativeXInd){
    var int backgroundIndex;  // Index in the background mesh
    var int backgroundXInd;  // The x coordinate of the background mesh
    var int backgroundYInd;  // The y coordinate of the background mesh
    var int meshXInd;  // The x coordinate of the input mesh
    var int meshYInd;  // The y coordinate of the input mesh
    var int startPixelX;  // The pixel column to start draw a rectangle from
    var int startPixelY;  // The pixel row to start draw a rectangle from

    var bool state;  // State of the current input mesh element

    // Will be destroyed by the Mesh
    var Array backgroundCoordinates;  // Array holding the (x, y) coordinate of the background mesh

    let backgroundIndex = skipRows * meshCols;

    while (backgroundIndex < backgroundMesh.getMeshLength()){
      // Get the background coordinates
      let backgroundCoordinates = backgroundMesh.getMeshIndices(backgroundIndex);
      let backgroundXInd = backgroundCoordinates[0];
      let backgroundYInd = backgroundCoordinates[1];

      // Get the input mesh coordinates
      let meshXInd = backgroundXInd - relativeXInd;
      let meshYInd = backgroundYInd - relativeYInd;

      // Only proceed if meshXInd and meshYInd is within the range
      if (
        // Check the x coordinate
        ((-1 < meshXInd) & (meshXInd < mesh.getCols())) &
        // Check the y coordinate
        ((-1 < meshYInd) & (meshYInd < mesh.getRows()))
      ){
        // NOTE: We need the actual y-coordinate to get the state
        let state = mesh.getState(meshYInd, meshXInd);
        // NOTE: We only draw the active part of the mesh as the inactive part
        //       may overlap with the background
        // FIXME: Need another way of not drawing active state...if not can get probs with collapse
        // if(state){
          // Subtract rows to skip, so that we only draw the visible part of the mesh
          let backgroundYInd = backgroundYInd - skipRows;
          let startPixelX = tetrominoStartX + (tetrominoElementSize*backgroundXInd) + (2*backgroundXInd);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*backgroundYInd) + (2*backgroundYInd);

          if(erase){
            do Screen.setColor(false);
          } else {
            do Screen.setColor(state);
          }
          do Screen.drawRectangle(startPixelX,
                                  startPixelY,
                                  startPixelX+tetrominoElementSize,
                                  startPixelY+tetrominoElementSize);
        // }

      }

      let backgroundIndex = backgroundIndex + 1;
    }

    return;
  }

  /**
   * Draw specific rows with a certain color
   *
   * \param rowsToDraw Rows to draw with the color
   * \param color The color to draw
   */
  method void drawRows(Array rowsToDraw, bool color){
    var int xInd;  // The x coordinate of the Mesh
    var int curRow;  // The y coordinate of the Mesh
    var int visibleRow;  // The y coordinate of visible row
    var bool drawRow;  // Whether or not to draw the row
    var int startPixelX;  // The pixel column to start draw a rectangle from
    var int startPixelY;  // The pixel row to start draw a rectangle from

    let curRow = skipRows;

    do Screen.setColor(color);

    // Loop over all visible rows
    while(curRow < meshRows){
      let visibleRow = curRow - skipRows;
      let drawRow = rowsToDraw[visibleRow];

      if(drawRow){
        let xInd = 0;

        // Loop over all rows in a column
        while (xInd < meshCols){
          let startPixelX = tetrominoStartX + (tetrominoElementSize*xInd) + (2*xInd);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*visibleRow) + (2*visibleRow);
          do Screen.drawRectangle(startPixelX, startPixelY, startPixelX+tetrominoElementSize, startPixelY+tetrominoElementSize);
          let xInd = xInd + 1;
        }
      }
      let curRow = curRow + 1;
    }

    return;
  }

  /**
   * Animate clear lines
   *
   * \param rowsToClear Rows to draw with the color
   */
  method void clearLinesAnimation(Array rowsToClear){
    var int curRow;  // The y coordinate of the Mesh
    var int visibleRow;  // The y coordinate of visible row
    var bool clearRow;  // Whether or not to draw the row
    var int startPixelX;  // The pixel column to start draw a rectangle from
    var int startPixelY;  // The pixel row to start draw a rectangle from

    var int xIndHalf;
    var int xIndRight;
    var int xIndLeft;
    var int xIndRightCounter;
    var int xIndLeftCounter;

    let xIndHalf = (meshCols/2);
    let xIndLeftCounter = 1;
    let xIndRight = xIndHalf + xIndRightCounter;
    let xIndLeft = xIndRight - xIndLeftCounter;

    do Screen.setColor(false);

    // Loop over half the xInds
    while(xIndRight < meshCols){

      // Loop over all visible rows
      let curRow = skipRows;
      while(curRow < meshRows){
        let visibleRow = curRow - skipRows;
        let clearRow = rowsToClear[visibleRow];

        if(clearRow){
          // Remove the right element
          let startPixelX = tetrominoStartX + (tetrominoElementSize*xIndRight) + (2*xIndRight);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*visibleRow) + (2*visibleRow);
          do Screen.drawRectangle(startPixelX, startPixelY, startPixelX+tetrominoElementSize, startPixelY+tetrominoElementSize);
          // Remove the left element
          let startPixelX = tetrominoStartX + (tetrominoElementSize*xIndLeft) + (2*xIndLeft);
          let startPixelY = tetrominoStartY + (tetrominoElementSize*visibleRow) + (2*visibleRow);
          do Screen.drawRectangle(startPixelX, startPixelY, startPixelX+tetrominoElementSize, startPixelY+tetrominoElementSize);
        }

        let curRow = curRow + 1;
      }

      let xIndLeftCounter = xIndLeftCounter + 2;
      let xIndRightCounter = xIndRightCounter + 1;

      let xIndRight = xIndHalf + xIndRightCounter;
      let xIndLeft = xIndRight - xIndLeftCounter;

      do Sys.wait(100);
    }

    return;
  }

}
