/**
 * Implements the Tetromino class
 */

/**
 * Class which deals with the tetrominos in the following way
 * - Movement (side-ways, down, rotate)
 * - Checks if it can be placed in another mesh without colliding with elements
 *   or be out of bounds
 * - Draw and erase the tetromino within another mesh
 */
class Tetromino {
  field int relativeXInd;  // x-coordinate in the background mesh (i.e. not the tetromino mesh coordinate) relative to top left corner of relativeMesh
  field int relativeYInd;  // y-coordinate in the background mesh (i.e. not the tetromino mesh coordinate) relative to top left corner of relativeMesh

  field Mesh tetrominoMesh;  // The mesh of the tetromino itself
  field Background background;  // The background to interact with

  static int allocs;  // Number of times this has been allocated

  /**
   * Construct the tetromino
   *
   * \param tetrominoMesh_ The mesh of the tetromino itself
   * \param relativeXInd_ x-coordinate in the background mesh (i.e. not the tetromino mesh coordinate) relative to top left corner of relativeMesh
   * \param relativeYInd_ y-coordinate in the background mesh (i.e. not the tetromino mesh coordinate) relative to top left corner of relativeMesh
   * \param background_ The background to interact with
   */
  constructor Tetromino new(Mesh tetrominoMesh_,
                            int relativeXInd_,
                            int relativeYInd_,
                            Background background_) {
    let tetrominoMesh = tetrominoMesh_;

    let relativeXInd = relativeXInd_;
    let relativeYInd = relativeYInd_;

    let background = background_;

    let allocs = allocs + 1;

    return this;
  }

  /**
   * Destroy the Tetromino
   *
   * Disposes:
   * - The tetrominoMesh
   * - This
   */
  method void dispose (){
    let allocs = allocs - 1;

    do tetrominoMesh.dispose();
    do Memory.deAlloc(this);
    return;
  }

  /** Print the number of allocs */
  method void printAlloc (){
    var String str;
    let str = "Tetromino allocs: ";
    do Output.printString(str);
    do Output.printInt(allocs);
    do str.dispose();
    return;
  }

  /** Return the tetrominoMesh */
  method int getTetrominoMesh(){
    return tetrominoMesh;
  }

  /** Return relativeXInd */
  method int getRelativeIndX(){
    return relativeXInd;
  }

  /** Return relativeYInd */
  method int getRelativeIndY(){
    return relativeYInd;
  }

  /**
   * Set the background
   *
   * \param background The new background
   */
  method void setBackground(Background background_){
    let background = background_;
    return;
  }

  /**
   * Set the relative position
   *
   * \param yInd The relative y index
   * \param xInd The relative x index
   */
  method void setRelativePosition(int yInd, int xInd){
    let relativeYInd = yInd;
    let relativeXInd = xInd;
    return;
  }

  /**
   * Rotate the tetromino clockwise
   */
  method void rotate(){
    return;
  }

  /**
   * Return true if it's possible to spawn the tetromino in the gameMesh
   *
   * \return true if it's possible to spawn the tetromino
   */
  method bool canSpawn(){
    var bool canBeSpawn;

    let canBeSpawn = canBePlaced(relativeXInd, relativeYInd);

    if(canBeSpawn){
      do background.drawMesh(false, tetrominoMesh, relativeXInd, relativeYInd);
      return true;
    } else{
      return false;
    }
  }

  /**
   * Return true if it's possible to place the tetromino with the new coordinates in the gameMesh
   *
   * \param newrelativeXInd The new x-coordinate in the gameMesh
   * \param newrelativeYInd The new y-coordinate in the gameMesh
   * \return true if it's possible to place the tetromino
   */
  method bool canBePlaced(int newrelativeXInd, int newrelativeYInd){
    var int tetrominoMeshIndex;
    var int tetrominoXIndex;
    var int tetrominoYIndex;
    var int gameXInd;
    var int gameYInd;

    var Array tetrominoIndices;  // Will be destroyed by the Mesh
    var Mesh gameMesh;

    let gameMesh = background.getBackgroundMesh();

    while(tetrominoMeshIndex < tetrominoMesh.getMeshLength()){
      let tetrominoIndices = tetrominoMesh.getMeshIndices(tetrominoMeshIndex);
      let tetrominoXIndex = tetrominoIndices[0];
      let tetrominoYIndex = tetrominoIndices[1];

      let gameXInd = newrelativeXInd + tetrominoXIndex;
      let gameYInd = newrelativeYInd + tetrominoYIndex;

      // Check that x is within limits
      if (gameXInd < 0){ return false; }
      // -1 as gameXInd counts from 0
      if (gameXInd > (gameMesh.getCols() - 1)){ return false; }

      // Check that y is within limits
      if (gameYInd < 0){ return false; }
      // -1 as gameYInd counts from 0
      if (gameYInd > (gameMesh.getRows() - 1)){ return false; }

      // Check whether we would collide
      if (gameMesh.getState(gameYInd, gameXInd)){ return false; }
      let tetrominoMeshIndex = tetrominoMeshIndex + 1;
    }

    return true;
  }

  /**
   * Return true if it's possible to move the tetromino down in the gameMesh
   *
   * \return true if it's possible to move the tetromino down
   */
  method bool canMoveDown(){
    var int newrelativeYInd;
    var bool canPlace;

    let newrelativeYInd = relativeYInd + 1;
    let canPlace = canBePlaced(relativeXInd, newrelativeYInd);

    return canPlace;
  }

  /**
   * Return true if it's possible to move the tetromino to the left in the gameMesh
   *
   * \return true if it's possible to move the tetromino to the left
   */
  method bool canMoveLeft(){
    var int newrelativeXInd;
    var bool canPlace;

    let newrelativeXInd = relativeXInd - 1;
    let canPlace = canBePlaced(newrelativeXInd, relativeYInd);
    return canPlace;
  }

  /**
   * Return true if it's possible to move the tetromino to the right in the gameMesh
   *
   * \return true if it's possible to move the tetromino to the right
   */
  method bool canMoveRight(){
    var int newrelativeXInd;
    var bool canPlace;

    let newrelativeXInd = relativeXInd + 1;
    let canPlace = canBePlaced(newrelativeXInd, relativeYInd);
    return canPlace;
  }

  /** Move the tetromino down in the game mesh */
  method void moveDown(){
    // Erase
    do background.drawMesh(true, tetrominoMesh, relativeXInd, relativeYInd);
    let relativeYInd = relativeYInd + 1;
    // Draw
    do background.drawMesh(false, tetrominoMesh, relativeXInd, relativeYInd);
    return;
  }

  /** Move the tetromino to the left in the game mesh */
  method void moveLeft(){
    // Erase
    do background.drawMesh(true, tetrominoMesh, relativeXInd, relativeYInd);
    let relativeXInd = relativeXInd - 1;
    // Draw
    do background.drawMesh(false, tetrominoMesh, relativeXInd, relativeYInd);
    return;
  }

  /** Move the tetromino to the right in the game mesh */
  method void moveRight(){
    // Erase
    do background.drawMesh(true, tetrominoMesh, relativeXInd, relativeYInd);
    let relativeXInd = relativeXInd + 1;
    // Draw
    do background.drawMesh(false, tetrominoMesh, relativeXInd, relativeYInd);
    return;
  }

}
