/**
 * Implements the Tetromino class
 */

 class Tetromino {
  field Mesh tetrominoMesh;
  // Relative to top left corner of relativeMesh
  field int relativeMeshX;
  field int relativeMeshY;
  field int tetrominoElementSize;
  field int frameStartX;
  field int frameStartY;

  constructor Tetromino new(Mesh tetrominoMesh_, int relativeMeshX_, int relativeMeshY_, int tetrominoElementSize_, int frameStartX_, int frameStartY_) {
    let tetrominoMesh = tetrominoMesh_;
    let relativeMeshX = relativeMeshX_;
    let relativeMeshY = relativeMeshY_;
    let tetrominoElementSize = tetrominoElementSize_;
    let frameStartX = frameStartX_;
    let frameStartY = frameStartY_;

    return this;
  }

  method void dispose (){
    do tetrominoMesh.dispose();
    do Memory.deAlloc(this);
    return;
  }

  method void rotate(){
    return;
  }

  // Returns true if it's possible to spawn the tetromino
  method bool spawn(Mesh gameMesh){
    var bool canSpawn;

    let canSpawn = canBePlaced(gameMesh, relativeMeshX, relativeMeshY);

    if(canSpawn){
      do draw();
      return true;
    } else{
      return false;
    }
  }

  method bool canBePlaced(Mesh gameMesh, int newRelativeMeshX, int newRelativeMeshY){
    var int tetrominoMeshIndex;
    var Array tetrominoIndices;
    var int tetrominoXIndex;
    var int tetrominoYIndex;
    var int gameXInd;
    var int gameYInd;

    while(tetrominoMeshIndex < tetrominoMesh.getMeshLenght()){
      let tetrominoIndices = tetrominoMesh.getMeshIndices(tetrominoMeshIndex);
      let tetrominoXIndex = tetrominoIndices[0];
      let tetrominoYIndex = tetrominoIndices[1];
      // FIXME: Unsure if need to dispose this
      // do tetrominoIndices.dispose();

      let gameXInd = newRelativeMeshX + tetrominoXIndex;
      let gameYInd = newRelativeMeshY + tetrominoYIndex;

      // Check that x is within limits
      if (gameXInd < 0){
        return false;
      }
      // -1 as gameXInd counts from 0
      if (gameXInd > (gameMesh.getCols() - 1)){
        return false;
      }

      // Check that y is within limits
      if (gameYInd < 0){
        return false;
      }

      // -1 as gameYInd counts from 0
      if (gameYInd > (gameMesh.getRows() - 1)){
        // do Output.printString("NOT");
        return false;
      }

      // Check whether we would collide
      if (gameMesh.getState(gameXInd, gameYInd)){
        return false;
      }
      let tetrominoMeshIndex = tetrominoMeshIndex + 1;
    }
    return true;
  }

  method bool canMoveDown(Mesh gameMesh){
    var int newRelativeMeshY;

    let newRelativeMeshY = relativeMeshY + 1;
    return canBePlaced(gameMesh, relativeMeshX, newRelativeMeshY);
  }

  method bool canMoveLeft(Mesh gameMesh){
    var int newRelativeMeshX;

    let newRelativeMeshX = relativeMeshX - 1;
    return canBePlaced(gameMesh, newRelativeMeshX, relativeMeshY);
  }

  method bool canMoveRight(Mesh gameMesh){
    var int newRelativeMeshX;

    let newRelativeMeshX = relativeMeshX + 1;
    return canBePlaced(gameMesh, newRelativeMeshX, relativeMeshY);
  }

  method void moveDown(){
    do erase();
    let relativeMeshY = relativeMeshY + 1;
    do draw();
    return;
  }

  method void moveLeft(){
    do erase();
    let relativeMeshX = relativeMeshX - 1;
    do draw();
    return;
  }

  method void moveRight(){
    do erase();
    let relativeMeshX = relativeMeshX + 1;
    do draw();
    return;
  }


  method int getTetrominoMesh(){
    return tetrominoMesh;
  }

  method int getRelativeMeshX(){
    return relativeMeshX;
  }

  method int getRelativeMeshY(){
    return relativeMeshY;
  }

  method void draw(){
    var int index;
    var Array indices;
    var int xInd;
    var int yInd;
    var int xStartPixel;
    var int yStartPixel;
    var bool state;

    let index = 0;
    while (index < tetrominoMesh.getMeshLenght()){
      // Reference system is tetromino
      let indices = tetrominoMesh.getMeshIndices(index);
      let xInd = indices[0];
      let yInd = indices[1];
      let state = tetrominoMesh.getState(xInd, yInd);

      // Reference system is relativeMesh
      let xInd = relativeMeshX + indices[0];
      // Subtract 20 from relativeMesh as the play field is 10x40 with only 10x20 showing
      let yInd = relativeMeshY - 20 + indices[1];

      // Only draw if termino is within the frame
      if(yInd > -1){
        let xStartPixel = frameStartX + (tetrominoElementSize*xInd) + (2*xInd);
        let yStartPixel = frameStartY + (tetrominoElementSize*yInd) + (2*yInd);

        do Screen.setColor(state);
        do Screen.drawRectangle(xStartPixel, yStartPixel, xStartPixel+tetrominoElementSize, yStartPixel+tetrominoElementSize);
      }
      let index = index + 1;
    }

    // FIXME: Unsure if should dispose mesh here, think no as everything is passed by reference
    return;
  }

  method void erase(){
    var int index;
    var Array indices;
    var int xInd;
    var int yInd;
    var int xStartPixel;
    var int yStartPixel;
    var bool state;

    let index = 0;
    while (index < tetrominoMesh.getMeshLenght()){
      // Reference system is relativeMesh
      let indices = tetrominoMesh.getMeshIndices(index);
      let xInd = relativeMeshX + indices[0];
      // Subtract 20 from relativeMesh as the play field is 10x40 with only 10x20 showing
      let yInd = relativeMeshY - 20 + indices[1];

      // Only erase if termino is within the frame
      if(yInd > -1){
        let xStartPixel = frameStartX + (tetrominoElementSize*xInd) + (2*xInd);
        let yStartPixel = frameStartY + (tetrominoElementSize*yInd) + (2*yInd);

        do Screen.setColor(false);
        do Screen.drawRectangle(xStartPixel, yStartPixel, xStartPixel+tetrominoElementSize, yStartPixel+tetrominoElementSize);
      }

      let index = index + 1;
    }

    // FIXME: Unsure if should dispose mesh here, think no as everything is passed by reference
    return;
  }

 }
