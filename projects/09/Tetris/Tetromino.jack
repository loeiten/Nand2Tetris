/**
 * Implements the Tetromino class
 */

 class Tetromino {
  field Mesh tetrominoMesh;
  // Relative to top left corner of relativeMesh
  field int relativeMeshX;
  field int relativeMeshY;
  field int tetrominoElementSize;
  field int frameStartX;
  field int frameStartY;

  constructor Tetromino new(Mesh tetrominoMesh_, int relativeMeshX_, int relativeMeshY_, int tetrominoElementSize_, int frameStartX_, int frameStartY_) {
    let tetrominoMesh = tetrominoMesh_;
    let relativeMeshX = relativeMeshX_;
    let relativeMeshY = relativeMeshY_;
    let tetrominoElementSize = tetrominoElementSize_;
    let frameStartX = frameStartX_;
    let frameStartY = frameStartY_;

    return this;
  }

  method void dispose (){
    do tetrominoMesh.dispose();
    do Memory.deAlloc(this);
    return;
  }

// FIXME:
  method void rotate(){
    return;
  }

  method void spawn(){
      do draw();
      // FIXME:
      do Output.printString("SPAWNED!!!");
      return;
  }

  method bool canMove(Mesh gameMesh, int newRelativeMeshX, int newRelativeMeshY){
    var int tetrominoMeshIndex;
    var Array tetrominoIndices;
    var int tetrominoXIndex;
    var int tetrominoYIndex;
    var int gameXInd;
    var int gameYInd;

    let tetrominoMeshIndex = 0;
      // FIXME: YOU ARE HERE: FIGURING OUT MYSTERY OF SUDDENLY TURNING TO 3
      do Output.moveCursor(15, 30);
      do Output.printInt(tetrominoMeshIndex);

    while(tetrominoMeshIndex < tetrominoMesh.getMeshLenght()){
      // FIXME:
      do Output.moveCursor(16, 30);
      do Output.printInt(tetrominoMeshIndex);

      let tetrominoIndices = tetrominoMesh.getMeshIndices(tetrominoMeshIndex);
      let tetrominoXIndex = tetrominoIndices[0];
      let tetrominoYIndex = tetrominoIndices[1];
      // FIXME: Unsure if need to dispose this
      // do tetrominoIndices.dispose();

      let gameXInd = newRelativeMeshX + tetrominoXIndex;
      let gameYInd = newRelativeMeshY + tetrominoYIndex;

      // Check that x is within limits
      if (gameXInd < 0){
        return false;
      }
      if (gameXInd > gameMesh.getCols()){
        return false;
      }

      // Check that y is within limits
      if (gameYInd < 0){
        return false;
      }

      // FIXME:
      do Output.moveCursor(9, 30);
      do Output.printInt(tetrominoMeshIndex);
      do Output.printString("BAALLZ");
      do Output.moveCursor(10, 30);
      do Output.printInt(gameYInd);
      do Output.moveCursor(11, 30);
      do Output.printInt(newRelativeMeshY);
      do Output.moveCursor(12, 30);
      do Output.printInt(tetrominoYIndex);
      if (gameYInd > gameMesh.getRows()){
        do Output.printString("NOT");
        return false;
      }
      do Output.moveCursor(13, 30);
      do Output.printString("Pass");

      // Check whether we would collide
      if (gameMesh.getState(gameXInd, gameYInd)){
        return false;
      }
      let tetrominoMeshIndex = tetrominoMeshIndex + 1;

      // FIXME:
      do Output.moveCursor(17, 30);
      do Output.printInt(tetrominoMeshIndex);
    }
    return true;
  }

  method bool canMoveDown(Mesh gameMesh){
    var int newRelativeMeshY;

    let newRelativeMeshY = relativeMeshY + 1;
    return canMove(gameMesh, relativeMeshX, newRelativeMeshY);
  }

  method void moveDown(){
    do erase();
      // FIXME:
    do Output.moveCursor(0, 0);
    do Output.printInt(relativeMeshY);
    let relativeMeshY = relativeMeshY + 1;
    do draw();
    return;
  }

  method int getTetrominoMesh(){
    return tetrominoMesh;
  }

  method int getRelativeMeshX(){
    return relativeMeshX;
  }

  method int getRelativeMeshY(){
    return relativeMeshY;
  }

  method void draw(){
    // FIXME: Some rows should not be drawn (e.g. spawn area)
    var int index;
    var Array indices;
    var int xInd;
    var int yInd;
    var int xStartPixel;
    var int yStartPixel;
    var bool state;

    let index = 0;
    while (index < tetrominoMesh.getMeshLenght()){
      // Reference system is tetromino
      let indices = tetrominoMesh.getMeshIndices(index);
      let xInd = indices[0];
      let yInd = indices[1];
      let state = tetrominoMesh.getState(xInd, yInd);

      // Reference system is relativeMesh
      let xInd = relativeMeshX + indices[0];
      // Subtract 20 from relativeMesh as the play field is 10x40 with only 10x20 showing
      let yInd = relativeMeshY - 20 + indices[1];

      // Only draw if termino is within the frame
      if(yInd > -1){
        let xStartPixel = frameStartX + (tetrominoElementSize*xInd) + (2*xInd);
        let yStartPixel = frameStartY + (tetrominoElementSize*yInd) + (2*yInd);

        // FIXME:
        do Output.moveCursor(3, 30);
        do Output.printInt(yStartPixel);
        do Output.moveCursor(4, 30);
        do Output.printInt(relativeMeshY);
        do Output.moveCursor(5, 30);
        do Output.printInt(frameStartY);
        do Output.moveCursor(6, 30);
        do Output.printInt(yInd);
        do Output.moveCursor(7, 30);

        do Screen.setColor(state);
        do Screen.drawRectangle(xStartPixel, yStartPixel, xStartPixel+tetrominoElementSize, yStartPixel+tetrominoElementSize);
      }
      let index = index + 1;
    }

    // FIXME: Unsure if should dispose mesh here, think no as everything is passed by reference
    return;
  }

  method void erase(){
    // FIXME: Some rows should not be drawn (e.g. spawn area)
    var int index;
    var Array indices;
    var int xInd;
    var int yInd;
    var int xStartPixel;
    var int yStartPixel;
    var bool state;

    let index = 0;
    while (index < tetrominoMesh.getMeshLenght()){
      // Reference system is relativeMesh
      let indices = tetrominoMesh.getMeshIndices(index);
      let xInd = relativeMeshX + indices[0];
      // Subtract 20 from relativeMesh as the play field is 10x40 with only 10x20 showing
      let yInd = relativeMeshY - 20 + indices[1];

      // Only erase if termino is within the frame
      if(yInd > -1){
        let xStartPixel = frameStartX + (tetrominoElementSize*xInd) + (2*xInd);
        let yStartPixel = frameStartY + (tetrominoElementSize*yInd) + (2*yInd);

        do Screen.setColor(false);
        do Screen.drawRectangle(xStartPixel, yStartPixel, xStartPixel+tetrominoElementSize, yStartPixel+tetrominoElementSize);
      }

      let index = index + 1;
    }

    // FIXME: Unsure if should dispose mesh here, think no as everything is passed by reference
    return;
  }

 }
