/**
  * Implements the NextTetrominos class.
  *
  * This class is responsible for
  * 1. Generating the 7-bags
  * 2. Returning the next tetromino
  * 3. Update the next display
  */

class NextTetrominos {
  field Background nextBackground; // The background for the next tetrominos
  field Background gameBackground_; // The background for the game
  field Mesh nextMesh;  // The mesh containing the next tetrominos
  field Array currentBag;  // The current 7-bag of next tetrominos
  field Array nextBag;  // The next 7-bag of next tetrominos
  field String nextString;  // String holding "Next"
  field int curBagIteration;  // The current bag iteration
  field int bagSize;  // The bag size

  /**
   * Construct the NextTetrominos object.
   *
   * \param gameBackground The background for the game
   */
  constructor NextTetrominos new(Background gameBackground) {

    let gameBackground_ = gameBackground;
    // Create the next background
    // FIXME: Do proper calculations and put it to readme
    // Subtract 1 from frameStartY, and added to frameLenY
    let nextBackground = Background.new(
      347, // frameStartX  // 155 + 122 + 70
      22,   // frameStartY
      56, // frameLenX + 2 + 2
      222, // frameLenY (209 + 1 for next line + 1 for frame line)
      7,  // tetrominoElementSize
      0,  // skipRows
      6,  // meshCols
      24   // meshRows
    );
    let nextMesh = nextBackground.getBackgroundMesh();

    // Set size and iteration
    let bagSize = 7;
    let curBagIteration = 0;

    // Construct the bags
    let currentBag = Array.new(bagSize);
    let nextBag = Array.new(bagSize);
    do generateBag(currentBag);
    do generateBag(nextBag);

    // Display
    do nextBackground.drawFrame();
    let nextString = "Next";
    do Output.moveCursor(1, 45);
    do Output.printString(nextString);
    do updateNextColumn();

    return this;
  }

  /** dispose this nextTetrominos object. */
  method void dispose(){
    do nextBackground.dispose();
    do currentBag.dispose();
    do nextBag.dispose();
    // NOTE: We dispose the strings in the destructor
    //       Destroying elsewhere appears to mess with field int initialization
    do nextString.dispose();
    do Memory.deAlloc(this);
    return;
  }

//  /**
//   * get the next tetromino
//   *
//   * \warning the returned tetromino must be manually destroyed
//   *
//   * \return the next tetromino
//   */
//  method tetromino getNextTetrominos(){
//    var tetromino curtetromino;
//    var Mesh curTetrominoMesh;
//    var int counter;
//
//    let curTetromino = currentBag[0];
//
//    // Advance all tetrominos in the current bag with one position
//    // NOTE: bagSize-1 as we are accessing counter + 1
//    while(counter < (bagSize - 1)){
//      let currentBag[counter] = currentBag[counter + 1];
//      let counter = counter + 1;
//    }
//    // Manually move over the first tetromino from the next bag to the current bag
//    // NOTE: -1 as we start to count from 0
//    let currentBag[bagSize - 1] = nextBag[0];
//    // Reset the counter
//    let counter = 0;
//    // Advance all tetrominos in the current bag with one position
//    // NOTE: bagSize-1 as we are accessing counter + 1
//    while(counter < (bagSize - 1)){
//      let nextBag[counter] = nextBag[counter + 1];
//      let counter = counter + 1;
//    }
//
//    if(curBagIteration = bagSize){
//      do generateBag(nextBag);
//      // Reset curBagIteration
//      let curBagIteration = 0;
//    } else {
//      // Update the curBagIteration
//      let curBagIteration = curBagIteration + 1;
//    }
//
//    // Update and draw the next column
//    do updateNextColumn();
//
//    // Update the tetromino
//    do curTetromino.setBackground(gameBackground_);
//    let curTetrominoMesh = curTetromino.getTetrominoMesh();
//    if (curTetrominoMesh.getMeshLength() = 16){
//      // 4x4 tetrominos
//      do curTetromino.setRelativePosition(19, 3);
//    } else {
//      // 3x3 tetrominos
//      do curTetromino.setRelativePosition(18, 3);
//    }
//
//    return curTetromino;
//  }
//
//  /**
//   * Generate a bag of tetrominos
//   *
//   * \param bag The bag where the tetrominos are to be put in
//   */
  method void generateBag(Array bag){
    // FIXME: Put in loop
    // var int counter;
    // let counter = 0;
    // while(counter < bagSize){
    //   // FIXME: Replace with random number generator
    //   let bag[counter] = TetrominoSpawner.spawnO();
    //   let counter = counter + 1;
    // }

    // NOTE: The relative x and y indices will be updated in updateNextColumn,
    //       so we might as well set them to 0 here

    let bag[0] = TetrominoSpawner.spawnI(nextMesh, 0, 0);
    let bag[1] = TetrominoSpawner.spawnJ(nextMesh, 0, 0);
    let bag[2] = TetrominoSpawner.spawnL(nextMesh, 0, 0);
    let bag[3] = TetrominoSpawner.spawnO(nextMesh, 0, 0);
    let bag[4] = TetrominoSpawner.spawnS(nextMesh, 0, 0);
    let bag[5] = TetrominoSpawner.spawnT(nextMesh, 0, 0);
    let bag[6] = TetrominoSpawner.spawnZ(nextMesh, 0, 0);

    // let bag[0] = 0;
    // let bag[1] = 0;
    // let bag[2] = 0;
    // let bag[3] = 0;
    // let bag[4] = 0;
    // let bag[5] = 0;
    // let bag[6] = 0;

    return;
  }
//
  /** Update and draw the next column */
  method void updateNextColumn(){
    var Tetromino curTetromino;
    var Mesh tetrominoMesh;

    var int counter;
    var int newRelativeYInd;
    var int tetrominoType;
    var int cellSpace;  // Allocate 4 elements to each cell
    var int padFirstTetromino;  // Pad if the first tetromino is 3x3
    var int padOTetromino;  // Pad the tetromino if count != 0 and name = O

    let cellSpace = 4;

    let curTetromino = currentBag[counter];
    let tetrominoMesh = curTetromino.getTetrominoMesh();

    // Clear the mesh
    do nextMesh.clearMesh();

    if(tetrominoMesh.getMeshLength() = 9){
      // Pad with one cell if the first tetromino is a 3x3 tetromino
      let padFirstTetromino = 1;
    } else {
      let padFirstTetromino = 0;
    }

    // NOTE: We only want to show the next tetrominos for bagSize - 1
    while (counter < (bagSize - 1)){
      let curTetromino = currentBag[counter];

      if(counter > 0){
        let tetrominoType = curTetromino.getTetrominoType();
        // In case we are dealing with a O tetromino:
        // We will negatively pad with one cell to align with the other tetrominos
        if(tetrominoType = 3){
          let padOTetromino = 1;
        } else {
          let padOTetromino = 0;
        }
      }

      // Update the location of the current bags
      let newRelativeYInd = (counter * cellSpace) + padFirstTetromino - padOTetromino;
      let tetrominoMesh = curTetromino.getTetrominoMesh();
      do curTetromino.setRelativePosition(newRelativeYInd, 1);
      do nextMesh.addTetrominoToMesh(curTetromino);

      let counter = counter + 1;
    }

    do nextBackground.drawMesh(false, nextMesh, 0, 0);

    return;
  }

}
