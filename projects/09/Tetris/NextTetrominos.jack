/**
  * Implements the NextTetrominos class.
  *
  * This class is responsible for
  * 1. Generating the 7-bags
  * 2. Returning the next tetromino
  * 3. Update the next display
  */

class NextTetrominos {
  field Background nextBackground; // The background for the next tetrominos
  field Background gameBackground_; // The background for the game
  field Mesh nextMesh;  // The mesh containing the next tetrominos
  field Array currentBag;  // The current 7-bag of next tetrominos
  field Array nextBag;  // The next 7-bag of next tetrominos
  field int curBagIteration;  // The current bag iteration
  field int bagSize;  // The bag size

  /**
   * Construct the NextTetrominos object.
   *
   * \param gameBackground The background for the game
   */
  constructor NextTetrominos new(Background gameBackground) {
    var String nextString;

    let gameBackground_ = gameBackground;
    // Create the next background
    // FIXME: Do proper calculations and put it to readme
    // Subtract 1 from frameStartY, and added to frameLenY
    let nextBackground = Background.new(
      347, // frameStartX  // 155 + 122 + 70
      22,   // frameStartY
      68, // frameLenX + 2 + 2
      200, // frameLenY (209 + 1 for next line + 1 for frame line)
      7,  // tetrominoElementSize
      0,  // skipRows
      6,  // meshCols
      17   // meshRows
    );
    let nextMesh = nextBackground.getBackgroundMesh();

    // Set size and iteration
    let bagSize = 7;
    let curBagIteration = 0;

    // Construct the bags
    let currentBag = Array.new(bagSize);
    let nextBag = Array.new(bagSize);
    do generateBag(currentBag);
    do generateBag(nextBag);

    // Display
    do nextBackground.drawFrame();
    let nextString = "Next";
    do Output.moveCursor(1, 46);
    do Output.printString(nextString);
    do nextString.dispose();

    return this;
  }

  /** Dispose this NextTetrominos object. */
  method void dispose(){
    do nextBackground.dispose();
    do currentBag.dispose();
    do nextBag.dispose();
    do Memory.deAlloc(this);
    return;
  }

  /**
   * Get the next tetromino
   *
   * \warning The returned tetromino must be manually destroyed
   *
   * \return The next tetromino
   */
  method Tetromino getNextTetrominos(){
    var Tetromino curTetromino;
    var Mesh curTetrominoMesh;
    var int counter;

    let curTetromino = currentBag[0];

    // Advance all tetrominos in the current bag with one position
    // NOTE: bagSize-1 as we are accessing counter + 1
    while(counter < (bagSize - 1)){
      let currentBag[counter] = currentBag[counter + 1];
      let counter = counter + 1;
    }
    // Manually move over the first tetromino from the next bag to the current bag
    // NOTE: -1 as we start to count from 0
    let currentBag[bagSize - 1] = nextBag[0];
    // Reset the counter
    let counter = 0;
    // Advance all tetrominos in the current bag with one position
    // NOTE: bagSize-1 as we are accessing counter + 1
    while(counter < (bagSize - 1)){
      let nextBag[counter] = nextBag[counter + 1];
      let counter = counter + 1;
    }

    if(curBagIteration = bagSize){
      do generateBag(nextBag);
      // Reset curBagIteration
      let curBagIteration = 0;
    } else {
      // Update the curBagIteration
      let curBagIteration = curBagIteration + 1;
    }

    // Update and draw the next column
    do updateNextColumn();

    // Update the tetromino
    do curTetromino.setBackground(gameBackground_);
    let curTetrominoMesh = curTetromino.getTetrominoMesh();
    if (curTetrominoMesh.getMeshLength() = 16){
      // 4x4 tetrominos
      do curTetromino.setRelativePosition(19, 3);
    } else {
      // 3x3 tetrominos
      do curTetromino.setRelativePosition(18, 3);
    }

    return curTetromino;
  }

  /**
   * Generate a bag of tetrominos
   *
   * \param bag The bag where the tetrominos are to be put in
   */
  method void generateBag(Array bag){
    // FIXME: Put in loop
    // var int counter;
    // let counter = 0;
    // while(counter < bagSize){
    //   // FIXME: Replace with random number generator
    //   let bag[counter] = TetrominoSpawner.spawnO();
    //   let counter = counter + 1;
    // }
    let bag[0] = TetrominoSpawner.spawnI(nextMesh, 0, 1);
    let bag[1] = TetrominoSpawner.spawnJ(nextMesh, 2, 1);
    let bag[2] = TetrominoSpawner.spawnL(nextMesh, 5, 1);
    let bag[3] = TetrominoSpawner.spawnO(nextMesh, 8, 1);
    let bag[4] = TetrominoSpawner.spawnS(nextMesh, 11, 1);
    let bag[5] = TetrominoSpawner.spawnT(nextMesh, 14, 1);
    let bag[6] = TetrominoSpawner.spawnZ(nextMesh, 0, 1);

    return;
  }

  /** Update and draw the next column */
  method void updateNextColumn(){
    var Tetromino curTetromino;

    var int counter;
    var int newRelativeYInd;
    var int cellSpace;  // Allocate 4 elements to each cell

    let cellSpace = 4;

    // NOTE: We only want to show the next tetrominos for bagSize - 1
    while (counter < (bagSize - 1)){
      // Update the location of the current bags
      let newRelativeYInd = counter * cellSpace;
      let curTetromino = currentBag[counter];
      do curTetromino.setRelativePosition(newRelativeYInd, 1);

      let counter = counter + 1;
    }

    do next.drawMesh(false, nextMesh, 0, 0);

    return;
  }

}
