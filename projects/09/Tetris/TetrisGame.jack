/**
 * Implements the Tetris game.
 */

class TetrisGame {
  field int frameStartX;
  field int frameStartY;
  field int elementSize;
  field int gameSpeed;

  field Frame gameFrame;
  field Mesh gameMesh;

  /** Constructs a new Tetris Game. */
  constructor TetrisGame new() {
    var int xLen;
    var int yLen;

    let frameStartX = 1;
    let frameStartY = 6;
    let xLen = 122;
    let yLen = 242;  // 240 + 1 for next line + 1 for frame line

    let elementSize = 10;

    let gameSpeed = 500;

    // Draw background frame
    do Screen.setColor(true);
    do Screen.drawLine(frameStartX, frameStartY, frameStartX + xLen, frameStartY);
    do Screen.drawLine(frameStartX, frameStartY, frameStartX, frameStartY + yLen);
    do Screen.drawLine(frameStartX + xLen, frameStartY, frameStartX + xLen, frameStartY + yLen);
    do Screen.drawLine(frameStartX, frameStartY + yLen, frameStartX + xLen, frameStartY + yLen);

    // Initialize the game frame and the game mesh
    let gameFrame = Frame.new(frameStartX + 2, frameStartY + 2, elementSize);
    // NOTE: The mesh is 40 according to
    // https://tetris.fandom.com/wiki/Tetris_Guideline#List_of_rules_(as_of_2009)
    let gameMesh = Mesh.new(10, 40);
    return this;
  }

  /** Disposes this game. */
  method void dispose() {
    do gameFrame.dispose();
    do gameMesh.dispose();
    do Memory.deAlloc(this);
    return;
  }

  /** Runs the game: handles the user's inputs and moves the tetris accordingly */
  method void run() {
    var bool gameOver;
    var bool canSpawn;
    var bool canSpawn;
    var int x;
    var int y;
    var int startX;
    var int startY;


    var Tetromino curTetromino;

    var Mesh tetrominoMesh;

    var TetrominoSpawner tetrominoSpawner;

    let startX = frameStartX + 2;  // +1 for fram line and +1 for whitespace padding
    let startY = frameStartY + 2;  // +1 for fram line and +1 for whitespace padding

    do Screen.setColor(true);

    // Test locking tetrominos
    let tetrominoSpawner = TetrominoSpawner.new(frameStartX, frameStartY);
    // FIXME: Let game end by Top out: https://tetris.fandom.com/wiki/Top_out
    while (~gameOver){
      let curTetromino = tetrominoSpawner.getO();
      let canSpawn = curTetromino.spawn(gameMesh);
      if(canSpawn){
        // FIXME: Can be game over by top out
        do tetrominoFall(curTetromino);
      }
      let gameOver = ~canSpawn;
    }

    // FIXME: Real mesh must have some rows hidden for user

    // We can now free the memory as these are no longer needed
    do curTetromino.dispose();
    do tetrominoSpawner.dispose();

    do Output.moveCursor(11, 3);
    do Output.printString("Game over!");

    do Sys.wait(2000);

    return;
  }

  method void tetrominoFall(Tetromino curTetromino){
    var int countDown;
    var int index;
    var int meshLenght;
    var int gameXInd;
    var int gameYInd;

    var char key;
    var bool falling;

    var Array tetrominoIndexArray;
    var Mesh tetrominoMesh;

    let tetrominoMesh = curTetromino.getTetrominoMesh();
    let meshLenght = tetrominoMesh.getMeshLenght();
    let countDown = gameSpeed;
    let falling = true;
    while(falling){
      // FIXME: Have counter which is updated instead of gameSpeed
      // FIXME: YOU ARE HERE: Game controls should maybe be here, with a count-down?




      // Wait for a key to be pressed
      while((key=0) & (countDown > 0)){
        let key = Keyboard.keyPressed();

        // FIXME:
        // do Output.moveCursor(0, 30);
        // do Output.printString("Key: ");
        // do Output.printInt(key);

        do Sys.wait(1);
        let countDown = countDown - 1;


        // FIXME: Hack
        // do Output.moveCursor(7, 30);
        // do Output.printString("Hey");
        // if(curTetromino.canMoveDown(gameMesh)){
        //   do curTetromino.moveDown();
        //   let countDown = gameSpeed;
        // }
        // let key = 130;
        // do Output.moveCursor(8, 30);
        // do Output.printString("Ho");
         // FIXME:
         // do Output.moveCursor(7, 30);
         // do Output.printString("countDown: ");
         // do Output.printInt(countDown);
         // do Output.moveCursor(8, 30);
         // do Output.printString("key: ");
         // do Output.printInt(key);
      }
      // do Output.moveCursor(9, 30);
      // do Output.printString("Outside the while loop");
      // do Output.moveCursor(10, 30);
      // do Output.printString("countDown: ");
      // do Output.printInt(countDown);
      // do Sys.wait(100);



      //    if (key = 81)  { let exit = true; }     // q key
      //    if (key = 90)  { do tetris.decSize(); } // z key
      //    if (key = 88)  { do tetris.incSize(); } // x key
      if (key = 131) { let countDown = 0; }   // up arrow
      if (key = 133) {    // down arrow
        if(curTetromino.canMoveDown(gameMesh)){
          do curTetromino.moveDown();
        }
      }

      // do Output.moveCursor(9, 30);
      // do Output.printString("Lo");
      if (key = 130) { // left arrow
        // do Output.moveCursor(10, 30);
        // do Output.printString("Bo");
        if(curTetromino.canMoveLeft(gameMesh)){
          // do Output.moveCursor(11, 30);
          // do Output.printString("Do");
          do curTetromino.moveLeft();
        }
      }
      // FIXME:
      // do Sys.wait(500);
      if (key = 132) {    // right arrow
        if(curTetromino.canMoveRight(gameMesh)){
          // do Output.moveCursor(11, 30);
          // do Output.printString("Do");
          do curTetromino.moveRight();
        }
      }

      // Wait for the key to be release to continue
      // If not the key will be registered several times as the
      // content of the "falling" while loop is traversed quite fast
      while(~(key=0) & (countDown > 0)){
        let key = Keyboard.keyPressed();
        do Sys.wait(1);
        let countDown = countDown - 1;
      }

      if(countDown < 1){
        if(curTetromino.canMoveDown(gameMesh)){
          do curTetromino.moveDown();
          let countDown = gameSpeed;
        }
        else{
          let falling = false;
          // Add tetromino to the game mesh
          let index = 0;
          while(index < meshLenght){
            let tetrominoIndexArray = tetrominoMesh.getMeshIndices(index);
            let gameXInd = curTetromino.getRelativeMeshX() + tetrominoIndexArray[0];
            let gameYInd = curTetromino.getRelativeMeshY() + tetrominoIndexArray[1];
            do gameMesh.setState(gameXInd, gameYInd, true);
            let index = index + 1;
          // FIXME:
          // do Output.moveCursor(7, 30);
          // do Output.printString("index: ");
          // do Output.printInt(index);
          // do Output.moveCursor(8, 30);
          // do Output.printString("tetrominoIndexArray[0]: ");
          // do Output.printInt(tetrominoIndexArray[0]);
          // do Output.moveCursor(9, 30);
          // do Output.printString("tetrominoIndexArray[1]: ");
          // do Output.printInt(tetrominoIndexArray[1]);
          // do Output.moveCursor(10, 30);
          // do Output.printString("gameXInd: ");
          // do Output.printInt(gameXInd);
          // do Output.moveCursor(11, 30);
          // do Output.printString("gameYInd: ");
          // do Output.printInt(gameYInd);
          // do Sys.wait(1000);
          }
          do gameFrame.draw(gameMesh);
        }
      }
    }
    // The tetromino can now be destroyed
    do curTetromino.dispose();
    // FIXME: dispose array???
    // FIXME: dispose meshes???
    return;
  }

}
