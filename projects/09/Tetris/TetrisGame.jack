/**
 * Implements the Tetris game.
 */

/** Class responsible for updating the model of the game */
class TetrisGame {
  field NextTetromino nextTetromino;
  field int gameSpeed;  // Speed of the game

  field Background gameBackground;  // The game background
  // Destroyed by the gameBackground
  field Mesh gameMesh;  // The game mesh

  /**
   * Construct a new Tetris Game.
   *
   * The constructor will:
   * - Draw the background frame
   * - Initialize the background
   */
  constructor TetrisGame new() {
    // Set initial game speed
    // FIXME: Make game speed work with level
    let gameSpeed = 500;

    // FIXME: No underscores in public API
    // Initialize the background (see README.md for calculation)
    // NOTE: The mesh is 40 according to
    // https://tetris.fandom.com/wiki/Tetris_Guideline#List_of_rules_(as_of_2009)
    let gameBackground = Background.new(185, // frameStartX_  // FIXME: Fiddle around with pixels to look nice + 20
                                        6,   // frameStartY_
                                        122, // frameLenX_
                                        242, // frameLenY_ (240 + 1 for next line + 1 for frame line)
                                        10,  // tetrominoElementSize_
                                        20,  // skipRows_
                                        10,  // meshCols_
                                        40   // meshRows_
                                        );
    let gameMesh = gameBackground.getBackgroundMesh();
    do gameBackground.drawFrame();

    let nextTetromino = NextTetromino.new();

    return this;
  }

  /** Dispose this game. */
  method void dispose() {
    do nextTetromino.dispose();
    do gameBackground.dispose();
    do Memory.deAlloc(this);
    return;
  }

  /**
   * Run the game by:
   *
   * 1. Prepare the tetromino sequence (7-bag draw)
   * 2. Spawning a tetromino
   * 3. Let it fall (capturing of keystrokes happens during fall)
   * 4. Check if a row is covered and remove the row
   * 5. Update the score
   * 6. Check if the game is over
   */
  method void run() {
    var bool doSpawn;  // Whether we will spawn or not
    var bool gameOver;  // Whether the game is over or not

    var Tetromino curTetromino;  // The current tetromino

    // FIXME: Must also dispose
    var Background statistics;
    var Mesh statMesh;
    var Background next;
    var Mesh nextMesh;

    // FIXME: Remove
    var int testRow;
    var int testCol;
    let testRow = 39;

    // Subtract 1 from frameStartY, and added to frameLenY
    // FIXME:
    let statistics = Background.new(
      35, // frameStartX_  // FIXME: Fiddle around with numbers to look nice
      22,   // frameStartY_
      107, // frameLenX_
      232, // frameLenY_ (240 + 1 for next line + 1 for frame line)
      9,  // tetrominoElementSize_
      0,  // skipRows_
      6,  // meshCols_
      21   // meshRows_
    );
    do statistics.drawFrame();
    let statMesh = statistics.getBackgroundMesh();
    // do statMesh.setState(0, 0,true);
    // do statMesh.setState(20, 5, true);

    // Draw I
    do statMesh.setState(1, 1, true);
    do statMesh.setState(1, 2, true);
    do statMesh.setState(1, 3, true);
    do statMesh.setState(1, 4, true);
    // Draw J
    do statMesh.setState(3, 1, true);
    do statMesh.setState(4, 1, true);
    do statMesh.setState(4, 2, true);
    do statMesh.setState(4, 3, true);
    // Draw L
    do statMesh.setState(6, 3, true);
    do statMesh.setState(7, 1, true);
    do statMesh.setState(7, 2, true);
    do statMesh.setState(7, 3, true);
    // Draw O
    do statMesh.setState(9, 1,  true);
    do statMesh.setState(9, 2,  true);
    do statMesh.setState(10, 1, true);
    do statMesh.setState(10, 2, true);
    // Draw S
    do statMesh.setState(12, 2, true);
    do statMesh.setState(12, 3, true);
    do statMesh.setState(13, 1, true);
    do statMesh.setState(13, 2, true);
    // Draw T
    do statMesh.setState(15, 2, true);
    do statMesh.setState(16, 1, true);
    do statMesh.setState(16, 2, true);
    do statMesh.setState(16, 3, true);
    // Draw Z
    do statMesh.setState(18, 1, true);
    do statMesh.setState(18, 2, true);
    do statMesh.setState(19, 2, true);
    do statMesh.setState(19, 3, true);

    do statistics.drawMesh(false, statMesh, 0, 0);
    // do Output.moveCursor(2, 13);
    // do Output.printInt(100);
    do Output.moveCursor(3, 13);
    do Output.printInt(2);
    // do Output.moveCursor(4, 13);
    // do Output.printInt(300);
    // do Output.moveCursor(5, 13);
    // do Output.printInt(400);
    do Output.moveCursor(6, 13);
    do Output.printInt(500);
    // do Output.moveCursor(7, 13);
    // do Output.printInt(600);
    // do Output.moveCursor(8, 13);
    // do Output.printInt(700);
    do Output.moveCursor(9, 13);
    do Output.printInt(800);
    // do Output.moveCursor(10, 13);
    // do Output.printInt(900);
    // do Output.moveCursor(11, 13);
    // do Output.printInt(1000);
    do Output.moveCursor(12, 13);
    do Output.printInt(1100);
    // do Output.moveCursor(13, 13);
    // do Output.printInt(1200);
    // do Output.moveCursor(14, 13);
    // do Output.printInt(1300);
    do Output.moveCursor(15, 13);
    do Output.printInt(1400);
    // do Output.moveCursor(16, 13);
    // do Output.printInt(1500);
    // do Output.moveCursor(17, 13);
    // do Output.printInt(1600);
    do Output.moveCursor(18, 13);
    do Output.printInt(1700);
    // do Output.moveCursor(19, 13);
    // do Output.printInt(1800);
    // do Output.moveCursor(20, 13);
    // do Output.printInt(1900);
    do Output.moveCursor(21, 13);
    do Output.printInt(20000);
    // do Output.moveCursor(22, 13);
    // do Output.printInt(21000);

    do Output.moveCursor(1, 6);
    do Output.printString("Statistics");

    // do Output.moveCursor(1, 0);
    // do Output.printString("Next");
    // do Output.moveCursor(2, 0);
    // do Output.printString("Score:");
    // do Output.moveCursor(3, 0);
    // do Output.printString("Lines:");
    // do Output.moveCursor(4, 0);
    // do Output.printString("Level:");
    // do Output.moveCursor(5, 0);
    // do Output.printInt(32000);


    do Output.moveCursor(1, 46);
    do Output.printString("Next");

    // FIXME:
    do Output.moveCursor(11, 26);
    do Output.printString(" Game over! ");

    do Output.moveCursor(2, 55);
    do Output.printString("Score:");
    do Output.moveCursor(3, 55);
    do Output.printInt(20000);

    do Output.moveCursor(7, 55);
    do Output.printString("Lines:");
    do Output.moveCursor(8, 55);
    do Output.printInt(30000);

    do Output.moveCursor(12, 55);
    do Output.printString("Level:");
    do Output.moveCursor(13, 55);
    do Output.printInt(30000);

    // FIXME: TestMesh
    while(testRow > 28){
      let testCol = 0;
      while (testCol < 10){
        do gameMesh.setState(testRow, testCol, true);
        let testCol = testCol + 1;
      }
      let testRow = testRow - 1;
    }

    // Make holes
    do gameMesh.setState(39, 0, false);
    do gameMesh.setState(39, 2, false);
    do gameMesh.setState(39, 4, false);
    do gameMesh.setState(39, 6, false);
    do gameMesh.setState(39, 8, false);
    // 38 is due to clearing
    do gameMesh.setState(37, 1, false);
    do gameMesh.setState(37, 3, false);
    do gameMesh.setState(37, 5, false);
    do gameMesh.setState(37, 7, false);
    do gameMesh.setState(37, 9, false);
    // 36 - 35 is due to clearing
    do gameMesh.setState(34, 0, false);
    do gameMesh.setState(34, 4, false);
    do gameMesh.setState(34, 5, false);
    do gameMesh.setState(34, 9, false);
    // 33 - 30 is due to clearing
    do gameMesh.setState(29, 1, false);
    do gameMesh.setState(29, 8, false);

    do gameBackground.drawMesh(false, gameMesh, 0, 0);





    // Run until game over
    while (~gameOver){
      let curTetromino = TetrominoSpawner.getO(gameBackground);
      let doSpawn = curTetromino.canSpawn();

      if(doSpawn){
        // Enter the fall sequence
        do tetrominoFall(curTetromino);
      }
      // The game can end by "Top out" if a tetromino cannot spawn:
      // https://tetris.fandom.com/wiki/Top_out
      let gameOver = ~doSpawn;

      // Dispose the current tetromino
      do curTetromino.dispose();
    }

    // Display game over
    // FIXME:
    do Output.moveCursor(11, 26);
    do Output.printString(" Game over! ");

    return;
  }

  /** Let the tetromino fall and move it around while falling */
  method void tetrominoFall(Tetromino curTetromino){
    var int countDown;  // Count down until next move down
    var bool falling;  // Whether or not the tetromino is still falling
    var char key;  // Variable for capturing key stroke
    var char prevKey;  // Variable for the previous key stroke

    let countDown = gameSpeed;
    let falling = true;

    while(falling){

      // Wait for a key to be pressed
      while(((key=0) & (countDown > 0))){
        let key = Keyboard.keyPressed();

        do Sys.wait(1);
        let countDown = countDown - 1;
      }
      // If the current key is the same as the previous key it's due to the key
      // not being released before the countDown ended
      // We therefore add a guard to make sure that the key get's properly released
      if (~(key = prevKey)){ do moveWithKeyboard(curTetromino, countDown, key); }
      let prevKey = key;

      // Wait for the key to be release to continue
      // If not the key will be registered several times as the
      // content of the "falling" while loop is traversed quite fast
      while((~(key=0)) & (countDown > 0)){
        let prevKey = 0;
        let key = Keyboard.keyPressed();
        do Sys.wait(1);
        let countDown = countDown - 1;
      }

      // If the time counts out we will add the tetromino with the mesh and destroy it
      // NOTE: We cannot set countDown < 0 to check if countDown is 0
      if(countDown < 1){
        if(curTetromino.canMoveDown()){
          do curTetromino.moveDown();
          let countDown = gameSpeed;
        }
        else{
          let falling = false;
          do addTetrominoToMesh(curTetromino);
          do removeFullLines();
        }
      }
    }
    return;
  }

  /**
   * Move the tetromino with the keyboard
   *
   * \param curTetromino The current tetromino
   * \param countDown Remaining time until lock
   * \param key Current key stroke
   */
  method void moveWithKeyboard(Tetromino curTetromino, int countDown, char key){
    // Capture up arrow
    if (key = 131) {
      let countDown = 0;
      while(curTetromino.canMoveDown()){
          do curTetromino.moveDown();
      }
    }
    // Capture down arrow
    if (key = 133) {
      if(curTetromino.canMoveDown()){
        do curTetromino.moveDown();
      }
    }
    // Capture left arrow
    if (key = 130) {
      if(curTetromino.canMoveLeft()){
        do curTetromino.moveLeft();
      }
    }
    // Capture right arrow
    if (key = 132) {
      if(curTetromino.canMoveRight()){
        do curTetromino.moveRight();
      }
    }

    return;
  }

  /**
   * Add the tetromino to the mesh
   *
   * \param curTetromino The current tetromino
   */
  method void addTetrominoToMesh(Tetromino curTetromino){
    var int gameXInd;  // x-coordinate in the gameMesh
    var int gameYInd;  // y-coordinate in the gameMesh
    var int tetrominoIndex;  // Index in the tetromino mesh

    var int tetrominoMeshLength;  // Length of the tetromino mesh
    // Will be destroyed when Mesh is destroyed in Tetromino
    var Array tetrominoIndexArray;  // The array for the tetromino coordinates
    // Will be destroyed by the Tetromino
    var Mesh tetrominoMesh;  // The tetromino mesh

    let tetrominoMesh = curTetromino.getTetrominoMesh();
    let tetrominoMeshLength = tetrominoMesh.getMeshLength();

    // Add tetromino to the game mesh
    let tetrominoIndex = 0;
    while(tetrominoIndex < tetrominoMeshLength){
      let tetrominoIndexArray = tetrominoMesh.getMeshIndices(tetrominoIndex);
      let gameXInd = curTetromino.getRelativeIndX() + tetrominoIndexArray[0];
      let gameYInd = curTetromino.getRelativeIndY() + tetrominoIndexArray[1];
      do gameMesh.setState(gameYInd, gameXInd, true);
      let tetrominoIndex = tetrominoIndex + 1;
    }
    do gameBackground.drawMesh(false, gameMesh, 0, 0);

    return;
  }

  /** Remove full lines */
  method void removeFullLines(){
    var Array rowsToRemove;
    var int nRowsToRemove;
    var int rowNumber;
    var int blinkSpeed;

    let blinkSpeed = 150;

    let rowsToRemove = getRowsToRemove();

    while(rowNumber < gameBackground.getVisibleRows()){
      if(rowsToRemove[rowNumber]){
        let nRowsToRemove = nRowsToRemove + 1;
      }
      let rowNumber = rowNumber + 1;
    }

    if(nRowsToRemove > 0){
      if (nRowsToRemove > 3){
        // Let the rows blink on Tetris
        do gameBackground.drawRows(rowsToRemove, false);
        do Sys.wait(blinkSpeed);
        do gameBackground.drawRows(rowsToRemove, true);
        do Sys.wait(blinkSpeed);
        do gameBackground.drawRows(rowsToRemove, false);
        do Sys.wait(blinkSpeed);
        do gameBackground.drawRows(rowsToRemove, true);
        do Sys.wait(blinkSpeed);
      }

      do gameBackground.clearLinesAnimation(rowsToRemove);

      // Collapse full rows
      do gameBackground.collapse(rowsToRemove);
    }

    // Created in getRowsToRemove
    do rowsToRemove.dispose();
    return;
  }

  /**
   * Get rows to remove
   *
   * \warning The returned array must be manually destroyed
   *
   * \return Array containing the rows to remove
   */
  method Array getRowsToRemove(){
    var int xInd;  // The x coordinate of the Mesh
    var int curRow;  // The y coordinate of the Mesh

    var bool foundWhiteSpace;
    var bool state;

    var Array rowsToRemove;
    var Mesh backgroundMesh;

    // Disposed in removeFullLines
    let rowsToRemove = Array.new(gameBackground.getVisibleRows());

    let backgroundMesh = gameBackground.getBackgroundMesh();
    let curRow = gameBackground.getSkipRows();

    // Loop over all visible rows
    while(curRow < gameBackground.getMeshRows()){
      let xInd = 0;

      // Loop over all rows in a column
      // Reset foundWhiteSpace
      let foundWhiteSpace = false;
      while ((xInd < backgroundMesh.getCols()) & (~foundWhiteSpace)){
        let state = backgroundMesh.getState(curRow, xInd);
        if(state = 0){
          let foundWhiteSpace = true;
        }
        let xInd = xInd + 1;
      }

      // If we didn't find a whitespace, mark the row for removal
      // NOTE: Although we dispose the rowsToRemove, the array is not initialized to zero
      //       Hence we must  specify both rows to remove and rows to keep
      if(~foundWhiteSpace){
        let rowsToRemove[curRow - gameBackground.getSkipRows()] = true;
      } else {
        let rowsToRemove[curRow - gameBackground.getSkipRows()] = false;
      }

      let curRow = curRow + 1;
    }

    return rowsToRemove;
  }

}
